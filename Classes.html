

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Documentation for Module Classes.py &mdash; peyeQM 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="peyeQM 1.0 documentation" href="index.html" />
    <link rel="up" title="Documentation for the code" href="code.html" />
    <link rel="next" title="Documentation for Module Interpreter.py" href="Interpreter.html" />
    <link rel="prev" title="Documentation for the code" href="code.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Interpreter.html" title="Documentation for Module Interpreter.py"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="code.html" title="Documentation for the code"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">peyeQM 1.0 documentation</a> &raquo;</li>
          <li><a href="code.html" accesskey="U">Documentation for the code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-Classes">
<span id="documentation-for-module-classes-py"></span><h1>Documentation for Module Classes.py<a class="headerlink" href="#module-Classes" title="Permalink to this headline">¶</a></h1>
<p>Classes module specifications.
.. module:: Classes</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">platform:</th><td class="field-body">Unix, Windows</td>
</tr>
<tr class="field-even field"><th class="field-name">synopsis:</th><td class="field-body">Holds class definitions for preprocessing stage of peyeQM</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Module Classes holds many of the classes used by PeYeQM to
define the instances necessary for the initial statement
of a simulation problem.</p>
<div class="section" id="list-of-classes">
<h2>List of Classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="simulation">
<h3>Simulation()<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h3>
<p>Top level class of a FEA. It contains as attributes all other classes listed 
below.
It has</p>
<blockquote>
<div><ul class="simple">
<li>Definition of the problem.</li>
<li>Details about the context of the solution.</li>
</ul>
</div></blockquote>
<dl class="class">
<dt id="Classes.Simulation">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Simulation</tt><a class="reference internal" href="_modules/Classes.html#Simulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the data of a simulation.</p>
<p>Instances from this class act as a container for the overal 
problem definition of the simulation.
A simulation instance is meant to contain information about:</p>
<blockquote>
<div><ul class="simple">
<li>The domain and its discretized representation.</li>
<li>The physics of the problem.</li>
<li>Details about the method of solution.</li>
</ul>
</div></blockquote>
<p>After instantiating a simulationone one gets an almost empty class.
In order to have an useful object, you have to read the input
data from a .msh that hasbeen prepared beforehand in the preprocessing
stage.</p>
<p>To read information of a file use the method read_solver_input()</p>
<p>&#64;ivar domain:  The Domain and its discretization.
&#64;ivar sim_type: 
&#64;ivar dimension: 
&#64;ivar time_dependency:</p>
<dl class="method">
<dt id="Classes.Simulation.read_solver_input">
<tt class="descname">read_solver_input</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Simulation.read_solver_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Simulation.read_solver_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the solver input from a file of gmsh ASCII format V2.2.</p>
<p>This input is to be read by the Solver module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; String 
which contain filename and path of the output file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">solver_input
List with the following parameters:
[dimension, bc_type, parameter, eq, sol_type, analysis_param]</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>dimension: int </dt>
<dd>Parameter that tells the program wether to solve for a
1D problem or a 2D problem. 1D problems are currently 
not supported.</dd>
<dt>bc_type: str</dt>
<dd><p class="first">Parameter for the selection of a boundary condition
that can be either:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;Dir&#8217;:</dt>
<dd>For the Dirichlet border condition
(Infinite potential well).</dd>
<dt>&#8216;Bloch&#8217;:</dt>
<dd>For the periodic formulation of the problem.
(Electron in a periodic material )</dd>
</dl>
</div></blockquote>
</dd>
<dt>body_parameter: numpy.array</dt>
<dd><p class="first">Is an array that describes the body force actuating over the
the elements of the domain. 
For each element in self.domain.elements
there is an associated potential value on the same
position in the array parameter. For EM this fiel is empty.</p>
<p class="last">The potential in Scroedinger equation defines the specific
nature of the problem to be solved. For more details on how
to define a potential and what does it mean please read the
documentation of the Potential1D function in the module PrePro.</p>
</dd>
<dt>sim_type: str</dt>
<dd>Can be &#8216;QM&#8217; from Quantum Mechanics, or &#8216;EM&#8217; for 
electromagnetism.</dd>
<dt>sol_type:  str</dt>
<dd><p class="first">Tells wether to solve the stationary version of the equation 
or dynamic one</p>
<blockquote class="last">
<div><ul class="simple">
<li>&#8216;Stationary&#8217;</li>
<li>&#8216;Transient&#8217;</li>
</ul>
</div></blockquote>
</dd>
<dt>solver_param:  list </dt>
<dd><p class="first">Array that contains the information regarding the number
of solutions to be computed and wether to save the values
or not.
analysis_param[0]:  str</p>
<blockquote>
<div>answer to the question, Save  Eigen Values?</div></blockquote>
<dl class="last docutils">
<dt>analysis_param[1]:  str</dt>
<dd>answer to the question  Save  Eigen Vectors?</dd>
<dt>analysis_param[2]:  int</dt>
<dd>number of Eigen Values to save.</dd>
<dt>analysis_param[3]:  int</dt>
<dd>number of Eigen Vectors to save.</dd>
<dt>analysis_param[4]:  int</dt>
<dd>number of wave numbers in x to sweep</dd>
<dt>analysis_param[5]:  int</dt>
<dd>number of wave numbers in y to sweep</dd>
<dt>analysis_param[6]:  int-float</dt>
<dd>biggest value of k. it may be the lenght of the dommain</dd>
</dl>
</dd>
<dt>bc_filename: str</dt>
<dd>tells where to look for the boundary conditions</dd>
</dl>
<p>Last modification: date 05/05/2013</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="domain">
<h3>Domain()<a class="headerlink" href="#domain" title="Permalink to this headline">¶</a></h3>
<p>Representation of the physical domain of a simulation. 
It has:</p>
<blockquote>
<div><ul class="simple">
<li>Information about regions and their discretization</li>
<li>definitions of elements, nodes and boundary conditions</li>
</ul>
</div></blockquote>
<dl class="class">
<dt id="Classes.Domain">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Domain</tt><a class="reference internal" href="_modules/Classes.html#Domain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Is a container to other classes and methods exclusive of the domain.</p>
<p>Instances from Domain Class contain the attributes that define 
characteristics of the simulation such as regions, meshing, and 
boundary conditions. They are somehow independent of the details
regarding the solution of the problem.</p>
<p>A domain is one of the principal components of the Simulation Class.
To be included here are instances of clases such as:</p>
<blockquote>
<div><ul class="simple">
<li>Regions.</li>
<li>Nodes.</li>
<li>Elements.</li>
<li>Boundaries.</li>
</ul>
</div></blockquote>
<p>These are the main attibutes of a domain in Finite Elemen Analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; Nodes()
After discretization space is reduced to points known as nodes,
each having unique coordinates. Nodes, is a class that contains
the coordinates of each node. for a FE model.</li>
<li><strong>elements</strong> &#8211; Elements()
The way in which FEA solves problems is by solving differential 
equations over chunks of the domain. These chunks are called 
elements, and as the name suggest they are characterized by being
finite. By defining these elements as simple interpolation 
function of nodes, one can create an approximate representation 
of space and solve the differential equations for these functions.
elements is an instance that contains information about the elemens
that form the domain.</li>
<li><strong>regions</strong> &#8211; list [ Region1, Region2 ]
regions is a list of instances of class region which will help 
us relate material properties with different sets of elements.</li>
<li><strong>boundaries</strong> &#8211; Boundaries()
As in any situation where one has to solve differential equations,
in FEA particular conditions have to be stated in some boundaries
of the domain in order to have unique solutions.
This instance has information about which boundaries have 
boundary conditions that are relevant to the solution of the 
simulation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Classes.Domain.read_bc_file">
<tt class="descname">read_bc_file</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Domain.read_bc_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Domain.read_bc_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads boundary confitions attributes from a .bc file.</p>
<p>.bc files are made by hand by the user, and by means of tags
relate line elements to pre-established values.
There are three kinds of boundary conditions
D: Dirichlet</p>
<blockquote>
<div>Conditions where one knows the value of the solution at the node.</div></blockquote>
<dl class="docutils">
<dt>N: Newman</dt>
<dd>Conditions where one knows the value of the derivative
of the  solution at the node.</dd>
<dt>B: Bloch</dt>
<dd>Made for Bloch periodicity</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; str 
which contains path and filename of input .bc file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Classes.Domain.read_mesh_file">
<tt class="descname">read_mesh_file</tt><big>(</big><em>filename</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Domain.read_mesh_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Domain.read_mesh_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads mesh characteristics from a .msh file of gmsh
ASCII format V2.2.</p>
<p>This method is meant to populate a domain instance by reading
nodes and elements from a .msh file.   
- Instances from Nodes and Elements are created.
- Function read_mesh() from module read_mesh.py is used to extract</p>
<blockquote>
<div>raw sets of elements and nodes.</div></blockquote>
<ul class="simple">
<li>raw sets are added to nodes and elements by using their method 
add()</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; str 
which contains path and filename of input .msh file.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyord vectorial:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Boolean
Tells if the problem is to be solved with a scalar or vectorial 
formulation. vectorial = True, builds two unknowns for each node.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Classes.Domain.read_regions_file">
<tt class="descname">read_regions_file</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Domain.read_regions_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Domain.read_regions_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads Region attributes from a .reg file exported by pickle.</p>
<p>This method is meant to populate a domain instance by reading
regions attributes from a .reg file.   
The .reg file is a list of instances of class Region() that has 
been exported by using python&#8217;s pickle function.
A .reg file contains elements, material properties, and a tag.</p>
<ul class="simple">
<li>Import the list</li>
<li>For each region in the list, add the elemtns that have its tag
by deep-copying them.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; str 
which contains path and filename of input .reg file.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="region">
<h3>Region()<a class="headerlink" href="#region" title="Permalink to this headline">¶</a></h3>
<p>A region is an object that allows the identification of different material 
properties according to a previous subdivision of the Domain.</p>
<dl class="class">
<dt id="Classes.Region">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Region</tt><big>(</big><em>tag=''</em>, <em>name=''</em>, <em>material_prop={}</em>, <em>elements={}</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Region" title="Permalink to this definition">¶</a></dt>
<dd><p>Reperesents a region of the Domain.</p>
<p>It is a way to store attributes that are specific to certain regions 
of the simulation such as the kind of elements that compose it, 
it&#8217;s distinctive tag, and material properties.</p>
</dd></dl>

</div>
<div class="section" id="nodes">
<h3>Nodes()<a class="headerlink" href="#nodes" title="Permalink to this headline">¶</a></h3>
<p>Class Nodes represents the coordinates of the points that result from 
a discretization of a given domain.</p>
<dl class="class">
<dt id="Classes.Nodes">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Nodes</tt><a class="reference internal" href="_modules/Classes.html#Nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Nodes, is a class that has coordinates for each node in a FE model.</p>
<p>Nodes, is an instance for handling nodes. Right now its only 
two attributes are the total number of nodes and the array of 
coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; int
Total number of nodes.</li>
<li><strong>coords</strong> &#8211; numpy.array
raw set of nodes as read from the mesh file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="elements">
<h3>Elements()<a class="headerlink" href="#elements" title="Permalink to this headline">¶</a></h3>
<p>Class elements is a container for sets of 1D and 2D elements that can be 
of different shapes and orders. Elements are representations of the 
relation between nodes of a discretized domain.  
Current supported elements are:</p>
<blockquote>
<div><ul class="simple">
<li>Lines</li>
<li>Triangles</li>
<li>Quadrilaterals</li>
</ul>
</div></blockquote>
<dl class="class">
<dt id="Classes.Elements">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Elements</tt><a class="reference internal" href="_modules/Classes.html#Elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains information about all elemens that form the domain.</p>
<p>Elements is a class that gets filled by interpreting an array of 
raw elements, instantiating objects of the relevant class for 
each elemnt.</p>
<p>If the reading of a .msh file gives line and quad elements, they are
saved into instances of classes Line() and Quadrilateral().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference external" href="http://docs.python.org/library/functions.html#all" title="(in Python v2.7)"><strong>all</strong></a> &#8211; dict of elements
all is a dictionary where all kinds of elements are indexed</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Classes.Elements.add">
<tt class="descname">add</tt><big>(</big><em>_elements</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Elements.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Elements.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to populate the class by interpreting a dict of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>_elements</strong> &#8211; dict of elements</li>
<li><strong>vectorial</strong> &#8211; Boolean
Tells if the elements are instantiated as vectorial elements.
vectorial = True, builds bigger matrices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lines">
<h3>Lines()<a class="headerlink" href="#lines" title="Permalink to this headline">¶</a></h3>
<p>An instance of class Lines() is a container of line elements. 
This class also defines common operations and attributes that 
involve line elements.</p>
<dl class="class">
<dt id="Classes.Lines">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Lines</tt><big>(</big><em>raw_lines</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for line elements and their methods.</p>
<blockquote>
<div><p>Line elements are used for solving 1D problems and handling 
boundary conditions. The instance lines has been made in order
to contain properties that are defined exlusively for line elements
such as stiffness matrices for 1D problems and
interpolation methods for newman and source vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ivar el_set:</th><td class="field-body">numpy.array
Has the tags and list of nodes for each line element.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">ivar n_elements:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">int
number of lines in el_set</td>
</tr>
<tr class="field-odd field"><th class="field-name">ivar order:</th><td class="field-body">int
Tells of what order the elements are. order = 0 stands for
linear interpolation functions and order = 2 for cuadratic lines.
Maximum order is 2.</td>
</tr>
<tr class="field-even field"><th class="field-name">ivar h:</th><td class="field-body">list of lambda functions
Is a list where interpolation functions for each node of the element
are defined. h depends on the order of the element.</td>
</tr>
</tbody>
</table>
<p>What we are trying to obtain when solving a FE problem is a function 
that represents the solution of a certain equation. By using  Finite 
elements  we form an abstraction of that function. Defining smaller 
compact suport functions that represent chunks of the domain, and 
assembling them carefully, we can build an approximate solution 
of complex problems whose analytical solution is out of reach.</p>
<p>These compact suport functions are stated as interpolation functions
of nodal values and their relative positions. 
The idea is that knowing nodal values and the positions of nodes, 
we are able to interpolate the solution and find the value of an 
arbitrary point. It is however an approximation, and the precision
of this value will be dependent of factors such as:</p>
<blockquote>
<div><ul class="simple">
<li>Number of nodes per element.</li>
<li>Order of the interpolation function.</li>
<li>complexity of the solution.</li>
</ul>
</div></blockquote>
<p>In peyeQM elements are isoparametric elements. This means that 
elents of any shape are mapped to a standard element from which 
it is easier to perform operations.</p>
<p>interpolation functions for the line element are:
..math:</p>
<div class="highlight-python"><pre>h_1 = </pre>
</div>
</div></blockquote>
<p>rac{1}{2}left( 1 - r 
ight ) if cuad:</p>
<blockquote>
<div><ul class="simple">
<li></li>
</ul>
</div></blockquote>
<p>rac{1}{2}left( 1 - r^2 
ight )</p>
<blockquote>
<div><dl class="docutils">
<dt>..math::</dt>
<dd>h_2 =</dd>
</dl>
</div></blockquote>
<p>rac{1}{2}left( 1 + r 
ight )  if cuad:</p>
<blockquote>
<div><ul class="simple">
<li></li>
</ul>
</div></blockquote>
<p>rac{1}{2}left( 1 - r^2 
ight )</p>
<blockquote>
<div><dl class="docutils">
<dt>..math::</dt>
<dd>h_3 = left( 1 - r</dd>
</dl>
</div></blockquote>
<p>ight )</p>
<dl class="method">
<dt id="Classes.Lines.extract_el_points">
<tt class="descname">extract_el_points</tt><big>(</big><em>_nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines.extract_el_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Lines.extract_el_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for the extracion of coordinates from nodes in a element.</p>
<p>Extracts the coordinates of the nodes in each line element and
retrieves an array of node coordinates.</p>
<p>loops inside an element reading the indexes of nodes and looks
for their coordinates in the matrix of nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> &#8211; numpy.array 
Of dimension (n_nodes, 3), where n_nodes is the 
number of nodes forming the mesh, and the three columns 
represent coordinates (x, y, z).</li>
<li><strong>el_id</strong> &#8211; int 
Index of the current element in the set of lines</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">node_coor: 
Array with coordinates of coordinate node. 
If the element is 3 node then array is 2*3
If it is a 2 node element then 2*2.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Classes.Lines.local_newman">
<tt class="descname">local_newman</tt><big>(</big><em>q</em>, <em>nodes</em>, <em>newman</em>, <em>tag</em>, <em>ln</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines.local_newman"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Lines.local_newman" title="Permalink to this definition">¶</a></dt>
<dd><p>Method used for the computation of the local Newman vector.</p>
<p>Returns the nodal values for a certain newman boundary line 
element by using the specific definition from the.bc file.</p>
<p>The Newman vector is constructed in order to define Newman boundary
conditions. It uses interpolation functions of line elements
and numerical integration to perform the calculation of components
q of the newman vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>q</strong> &#8211; Seems to be doing nothing, but I&#8217;m not removing it because 
there is no time to track a point from where it might be being 
invoqued.</li>
<li><strong>nodes</strong> &#8211; numpy.array
Array of coordinates for nodes, as read from the .msh file-</li>
<li><strong>newman</strong> &#8211; dict Boundaries.newman
dictionary that holds the information about what values or
expressions are assigned to a particular newmann bc.</li>
<li><strong>tag</strong> &#8211; str
id of the current boundary condition. dict newman may contain 
more than one relation, and tag is an identifier for selecting
one.</li>
<li><strong>vectorial</strong> &#8211; Boolean
Tells if the local vector is initiated to fit vectorial elements.
vectorial = True, builds two dof for each node in the element.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parama ln:</th><td class="field-body"><p class="first last">int
index of the current line element.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Classes.Lines.numeric_J">
<tt class="descname">numeric_J</tt><big>(</big><em>node_coords</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines.numeric_J"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Lines.numeric_J" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of the Jacobian of a line element</p>
<p>Jacobian is used for scaling of arbitrary line elements into the
isoparametric line defined by interpolation functions h.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_coords</strong> &#8211; numpy.array
Array containing coordinates of nodes in the line. As extracted 
using method Lines.extract_el_points().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">J
Jacobian of the input matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="triangles">
<h3>Triangles()<a class="headerlink" href="#triangles" title="Permalink to this headline">¶</a></h3>
<p>An instance of class Triangles() is a container of triangular elements. 
This class also defines common operations and attributes that 
involve triangular elements.</p>
<dl class="class">
<dt id="Classes.Triangles">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Triangles</tt><big>(</big><em>raw_triangles</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangles class is a container for triangular elements and their 
common methods.</p>
<p>Triangular elements are best suited for representing curved boundaries
and edges.</p>
<p>Triangles are one kind of very important elements</p>
<dl class="method">
<dt id="Classes.Triangles.calc_area">
<tt class="descname">calc_area</tt><big>(</big><em>lines</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles.calc_area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Triangles.calc_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the area of a triangle by using Heron&#8217;s theorem</p>
<p>line:  list of 3 2D arrays. Defines line segments of the triangle</p>
<p>area:  float number.</p>
</dd></dl>

<dl class="method">
<dt id="Classes.Triangles.extract_el_edges">
<tt class="descname">extract_el_edges</tt><big>(</big><em>points</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles.extract_el_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Triangles.extract_el_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the list of points given by &#8220;extract_el_points&#8221; and return 
a list of line segments from which the area can be calculated</p>
</dd></dl>

<dl class="method">
<dt id="Classes.Triangles.extract_el_points">
<tt class="descname">extract_el_points</tt><big>(</big><em>_nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles.extract_el_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Triangles.extract_el_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the coordinates of the nodes in each triangular element and
retrieves each vertice as a vector of two dimensions.</p>
<dl class="docutils">
<dt>nodes:  numpy array of dimension (n_nodes, 3), where n_nodes is the </dt>
<dd>number of nodes forming the mesh, and the three columns 
represent coordinates (x, y, z).</dd>
<dt>triangles:  numpy array of dimension (n_triangles, 4), where n_nodes </dt>
<dd>is the number of nodes forming the mesh, the first is the 
label that refers to the physical entity where each node 
belongs. The remaining columns  tell which nodes belong
to each of the vertices of the triangle.</dd>
</dl>
<p>el:   integer value of the current element</p>
<dl class="docutils">
<dt>pt_a, pt_b, pt_c:  vector like array of two dimensions where the first </dt>
<dd>is the position in x, and the second is the position 
of the node in y.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="quadrilaterals">
<h3>Quadrilaterals()<a class="headerlink" href="#quadrilaterals" title="Permalink to this headline">¶</a></h3>
<p>An instance of class Quadrilaterals() is a container of QUAD elements. 
This class also defines common operations and attributes that 
involve QUAD elements.</p>
</div>
<div class="section" id="boundaries">
<h3>Boundaries()<a class="headerlink" href="#boundaries" title="Permalink to this headline">¶</a></h3>
<p>This class acts as a container of boundaries and their attributes.
Boundaries of a domain are the objects where edge conditions are stated.</p>
<dl class="class">
<dt id="Classes.Boundaries">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Boundaries</tt><big>(</big><em>dirichlet={}</em>, <em>newman={}</em>, <em>bloch={}</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Boundaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Define what tags from physical entities are associated with certain 
boundary conditions.</p>
<dl class="method">
<dt id="Classes.Boundaries.bloch_multiplication">
<tt class="descname">bloch_multiplication</tt><big>(</big><em>k_x</em>, <em>k_y</em>, <em>nodes</em>, <em>ref_im</em>, <em>*matrices</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Boundaries.bloch_multiplication"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Boundaries.bloch_multiplication" title="Permalink to this definition">¶</a></dt>
<dd><p>This function multiplies a given matrix 
(in a future a given set of matrices), multiplies each Bloch boundary 
node, by the phase factor correspondent with it&#8217;s position.</p>
<p>k_x:       Current value of the x component from the wavenumber vector</p>
<p>k_y:       Current value of the y component from the wavenumber vector</p>
<dl class="docutils">
<dt>nodes:     Numpy array like matrix of node coordinates (n_nodes,3) where </dt>
<dd>coorsd(x,:)= x,y,z components of the node.</dd>
<dt>ref_im:    A list of 2-column numpy arrays. Each array in the list </dt>
<dd>&#8216;ref_im&#8217;, has in it&#8217;s first column the reference node and on it&#8217;s 
second column the image node for that particular reference node.</dd>
</dl>
<p>matrices:  Matrices to be operated.</p>
<dl class="docutils">
<dt>matrices:  The input matrix with all the phase multiplication operations </dt>
<dd>performed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Classes.Boundaries.bloch_sum">
<tt class="descname">bloch_sum</tt><big>(</big><em>ref_im</em>, <em>*matrices</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Boundaries.bloch_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Boundaries.bloch_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes the value of the image nodes in bloch periodicity 
boundaries, and sums it to the value of the reference node.</p>
<dl class="docutils">
<dt>ref_im:    A list of 2-column numpy arrays. Each array in the list </dt>
<dd>&#8216;ref_im&#8217;, has in it&#8217;s first column the reference node and on it&#8217;s 
second column the image node for that particular reference node.</dd>
</dl>
<p>matrices:  Matrices to be operated.</p>
<dl class="docutils">
<dt>matrices:  The input matrices but with the sums performed </dt>
<dd>and the image nodes columns and rows removed.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dof">
<h3>DOF()<a class="headerlink" href="#dof" title="Permalink to this headline">¶</a></h3>
<p>DOF is a class that was defined for transient simulations only.
A DOF represents a degree of freedom in a dynamic problem, and has the 
necessary attributes and methods for a time dependant algorithm</p>
<dl class="class">
<dt id="Classes.DOF">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">DOF</tt><big>(</big><em>node_id</em>, <em>simulation</em>, <em>t=None</em>, <em>comp=0</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#DOF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.DOF" title="Permalink to this definition">¶</a></dt>
<dd><p>A degree of freedom to solve for in a explicit methodology.
Attributes:</p>
<dl class="docutils">
<dt>node_id:        Number that represents the row that corresponds to a certain node in </dt>
<dd>the array of nodes.</dd>
</dl>
<p>boundary:  Boolean. df: false</p>
<p>region:  tells to which region it belongs</p>
<dl class="docutils">
<dt>vectorial: Tells if the degree of freedom is part of a vectorial formulation.</dt>
<dd>for 2D vectorial models we will have two dof&#8217;s per node.</dd>
</dl>
<p>comp:  0,1   If vectorial, this will tell if the dof corresponds to x or y component of the field.</p>
<p>s_elements:  List of surrounding elements</p>
<p>k:              Componento of the stiffness matrix built using the elements to which it belongs</p>
<dl class="method">
<dt id="Classes.DOF.check_if_in_boundary">
<tt class="descname">check_if_in_boundary</tt><big>(</big><em>simulation</em>, <em>t=None</em><big>)</big><a class="reference internal" href="_modules/Classes.html#DOF.check_if_in_boundary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.DOF.check_if_in_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Run throug line elements checking if this degree of freedom 
belongs to a bc line defined by a bc condition.</p>
<p>simulation:     Instance of class Simulation()</p>
<p>ln:     the number of the line to which the dof belongs</p>
</dd></dl>

<dl class="method">
<dt id="Classes.DOF.find_surrounding_elements">
<tt class="descname">find_surrounding_elements</tt><big>(</big><em>dofs</em>, <em>simulation</em><big>)</big><a class="reference internal" href="_modules/Classes.html#DOF.find_surrounding_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.DOF.find_surrounding_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop over elements looking for reference to the current node_id</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Boundaries</tt><big>(</big><em>dirichlet={}</em>, <em>newman={}</em>, <em>bloch={}</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Boundaries"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Define what tags from physical entities are associated with certain 
boundary conditions.</p>
<dl class="method">
<dt>
<tt class="descname">bloch_multiplication</tt><big>(</big><em>k_x</em>, <em>k_y</em>, <em>nodes</em>, <em>ref_im</em>, <em>*matrices</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Boundaries.bloch_multiplication"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function multiplies a given matrix 
(in a future a given set of matrices), multiplies each Bloch boundary 
node, by the phase factor correspondent with it&#8217;s position.</p>
<p>k_x:       Current value of the x component from the wavenumber vector</p>
<p>k_y:       Current value of the y component from the wavenumber vector</p>
<dl class="docutils">
<dt>nodes:     Numpy array like matrix of node coordinates (n_nodes,3) where </dt>
<dd>coorsd(x,:)= x,y,z components of the node.</dd>
<dt>ref_im:    A list of 2-column numpy arrays. Each array in the list </dt>
<dd>&#8216;ref_im&#8217;, has in it&#8217;s first column the reference node and on it&#8217;s 
second column the image node for that particular reference node.</dd>
</dl>
<p>matrices:  Matrices to be operated.</p>
<dl class="docutils">
<dt>matrices:  The input matrix with all the phase multiplication operations </dt>
<dd>performed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bloch_sum</tt><big>(</big><em>ref_im</em>, <em>*matrices</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Boundaries.bloch_sum"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This function takes the value of the image nodes in bloch periodicity 
boundaries, and sums it to the value of the reference node.</p>
<dl class="docutils">
<dt>ref_im:    A list of 2-column numpy arrays. Each array in the list </dt>
<dd>&#8216;ref_im&#8217;, has in it&#8217;s first column the reference node and on it&#8217;s 
second column the image node for that particular reference node.</dd>
</dl>
<p>matrices:  Matrices to be operated.</p>
<dl class="docutils">
<dt>matrices:  The input matrices but with the sums performed </dt>
<dd>and the image nodes columns and rows removed.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">DOF</tt><big>(</big><em>node_id</em>, <em>simulation</em>, <em>t=None</em>, <em>comp=0</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#DOF"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>A degree of freedom to solve for in a explicit methodology.
Attributes:</p>
<dl class="docutils">
<dt>node_id:        Number that represents the row that corresponds to a certain node in </dt>
<dd>the array of nodes.</dd>
</dl>
<p>boundary:  Boolean. df: false</p>
<p>region:  tells to which region it belongs</p>
<dl class="docutils">
<dt>vectorial: Tells if the degree of freedom is part of a vectorial formulation.</dt>
<dd>for 2D vectorial models we will have two dof&#8217;s per node.</dd>
</dl>
<p>comp:  0,1   If vectorial, this will tell if the dof corresponds to x or y component of the field.</p>
<p>s_elements:  List of surrounding elements</p>
<p>k:              Componento of the stiffness matrix built using the elements to which it belongs</p>
<dl class="method">
<dt>
<tt class="descname">check_if_in_boundary</tt><big>(</big><em>simulation</em>, <em>t=None</em><big>)</big><a class="reference internal" href="_modules/Classes.html#DOF.check_if_in_boundary"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Run throug line elements checking if this degree of freedom 
belongs to a bc line defined by a bc condition.</p>
<p>simulation:     Instance of class Simulation()</p>
<p>ln:     the number of the line to which the dof belongs</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">find_surrounding_elements</tt><big>(</big><em>dofs</em>, <em>simulation</em><big>)</big><a class="reference internal" href="_modules/Classes.html#DOF.find_surrounding_elements"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Loop over elements looking for reference to the current node_id</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Domain</tt><a class="reference internal" href="_modules/Classes.html#Domain"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Is a container to other classes and methods exclusive of the domain.</p>
<p>Instances from Domain Class contain the attributes that define 
characteristics of the simulation such as regions, meshing, and 
boundary conditions. They are somehow independent of the details
regarding the solution of the problem.</p>
<p>A domain is one of the principal components of the Simulation Class.
To be included here are instances of clases such as:</p>
<blockquote>
<div><ul class="simple">
<li>Regions.</li>
<li>Nodes.</li>
<li>Elements.</li>
<li>Boundaries.</li>
</ul>
</div></blockquote>
<p>These are the main attibutes of a domain in Finite Elemen Analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> &#8211; Nodes()
After discretization space is reduced to points known as nodes,
each having unique coordinates. Nodes, is a class that contains
the coordinates of each node. for a FE model.</li>
<li><strong>elements</strong> &#8211; Elements()
The way in which FEA solves problems is by solving differential 
equations over chunks of the domain. These chunks are called 
elements, and as the name suggest they are characterized by being
finite. By defining these elements as simple interpolation 
function of nodes, one can create an approximate representation 
of space and solve the differential equations for these functions.
elements is an instance that contains information about the elemens
that form the domain.</li>
<li><strong>regions</strong> &#8211; list [ Region1, Region2 ]
regions is a list of instances of class region which will help 
us relate material properties with different sets of elements.</li>
<li><strong>boundaries</strong> &#8211; Boundaries()
As in any situation where one has to solve differential equations,
in FEA particular conditions have to be stated in some boundaries
of the domain in order to have unique solutions.
This instance has information about which boundaries have 
boundary conditions that are relevant to the solution of the 
simulation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<tt class="descname">read_bc_file</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Domain.read_bc_file"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reads boundary confitions attributes from a .bc file.</p>
<p>.bc files are made by hand by the user, and by means of tags
relate line elements to pre-established values.
There are three kinds of boundary conditions
D: Dirichlet</p>
<blockquote>
<div>Conditions where one knows the value of the solution at the node.</div></blockquote>
<dl class="docutils">
<dt>N: Newman</dt>
<dd>Conditions where one knows the value of the derivative
of the  solution at the node.</dd>
<dt>B: Bloch</dt>
<dd>Made for Bloch periodicity</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; str 
which contains path and filename of input .bc file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">read_mesh_file</tt><big>(</big><em>filename</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Domain.read_mesh_file"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reads mesh characteristics from a .msh file of gmsh
ASCII format V2.2.</p>
<p>This method is meant to populate a domain instance by reading
nodes and elements from a .msh file.   
- Instances from Nodes and Elements are created.
- Function read_mesh() from module read_mesh.py is used to extract</p>
<blockquote>
<div>raw sets of elements and nodes.</div></blockquote>
<ul class="simple">
<li>raw sets are added to nodes and elements by using their method 
add()</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; str 
which contains path and filename of input .msh file.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyord vectorial:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Boolean
Tells if the problem is to be solved with a scalar or vectorial 
formulation. vectorial = True, builds two unknowns for each node.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">read_regions_file</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Domain.read_regions_file"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reads Region attributes from a .reg file exported by pickle.</p>
<p>This method is meant to populate a domain instance by reading
regions attributes from a .reg file.   
The .reg file is a list of instances of class Region() that has 
been exported by using python&#8217;s pickle function.
A .reg file contains elements, material properties, and a tag.</p>
<ul class="simple">
<li>Import the list</li>
<li>For each region in the list, add the elemtns that have its tag
by deep-copying them.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; str 
which contains path and filename of input .reg file.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Elements</tt><a class="reference internal" href="_modules/Classes.html#Elements"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Contains information about all elemens that form the domain.</p>
<p>Elements is a class that gets filled by interpreting an array of 
raw elements, instantiating objects of the relevant class for 
each elemnt.</p>
<p>If the reading of a .msh file gives line and quad elements, they are
saved into instances of classes Line() and Quadrilateral().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference external" href="http://docs.python.org/library/functions.html#all" title="(in Python v2.7)"><strong>all</strong></a> &#8211; dict of elements
all is a dictionary where all kinds of elements are indexed</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<tt class="descname">add</tt><big>(</big><em>_elements</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Elements.add"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Function to populate the class by interpreting a dict of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>_elements</strong> &#8211; dict of elements</li>
<li><strong>vectorial</strong> &#8211; Boolean
Tells if the elements are instantiated as vectorial elements.
vectorial = True, builds bigger matrices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Lines</tt><big>(</big><em>raw_lines</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Container for line elements and their methods.</p>
<blockquote>
<div><p>Line elements are used for solving 1D problems and handling 
boundary conditions. The instance lines has been made in order
to contain properties that are defined exlusively for line elements
such as stiffness matrices for 1D problems and
interpolation methods for newman and source vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ivar el_set:</th><td class="field-body">numpy.array
Has the tags and list of nodes for each line element.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">ivar n_elements:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">int
number of lines in el_set</td>
</tr>
<tr class="field-odd field"><th class="field-name">ivar order:</th><td class="field-body">int
Tells of what order the elements are. order = 0 stands for
linear interpolation functions and order = 2 for cuadratic lines.
Maximum order is 2.</td>
</tr>
<tr class="field-even field"><th class="field-name">ivar h:</th><td class="field-body">list of lambda functions
Is a list where interpolation functions for each node of the element
are defined. h depends on the order of the element.</td>
</tr>
</tbody>
</table>
<p>What we are trying to obtain when solving a FE problem is a function 
that represents the solution of a certain equation. By using  Finite 
elements  we form an abstraction of that function. Defining smaller 
compact suport functions that represent chunks of the domain, and 
assembling them carefully, we can build an approximate solution 
of complex problems whose analytical solution is out of reach.</p>
<p>These compact suport functions are stated as interpolation functions
of nodal values and their relative positions. 
The idea is that knowing nodal values and the positions of nodes, 
we are able to interpolate the solution and find the value of an 
arbitrary point. It is however an approximation, and the precision
of this value will be dependent of factors such as:</p>
<blockquote>
<div><ul class="simple">
<li>Number of nodes per element.</li>
<li>Order of the interpolation function.</li>
<li>complexity of the solution.</li>
</ul>
</div></blockquote>
<p>In peyeQM elements are isoparametric elements. This means that 
elents of any shape are mapped to a standard element from which 
it is easier to perform operations.</p>
<p>interpolation functions for the line element are:
..math:</p>
<div class="highlight-python"><pre>h_1 = </pre>
</div>
</div></blockquote>
<p>rac{1}{2}left( 1 - r 
ight ) if cuad:</p>
<blockquote>
<div><ul class="simple">
<li></li>
</ul>
</div></blockquote>
<p>rac{1}{2}left( 1 - r^2 
ight )</p>
<blockquote>
<div><dl class="docutils">
<dt>..math::</dt>
<dd>h_2 =</dd>
</dl>
</div></blockquote>
<p>rac{1}{2}left( 1 + r 
ight )  if cuad:</p>
<blockquote>
<div><ul class="simple">
<li></li>
</ul>
</div></blockquote>
<p>rac{1}{2}left( 1 - r^2 
ight )</p>
<blockquote>
<div><dl class="docutils">
<dt>..math::</dt>
<dd>h_3 = left( 1 - r</dd>
</dl>
</div></blockquote>
<p>ight )</p>
<dl class="method">
<dt>
<tt class="descname">extract_el_points</tt><big>(</big><em>_nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines.extract_el_points"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Method for the extracion of coordinates from nodes in a element.</p>
<p>Extracts the coordinates of the nodes in each line element and
retrieves an array of node coordinates.</p>
<p>loops inside an element reading the indexes of nodes and looks
for their coordinates in the matrix of nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> &#8211; numpy.array 
Of dimension (n_nodes, 3), where n_nodes is the 
number of nodes forming the mesh, and the three columns 
represent coordinates (x, y, z).</li>
<li><strong>el_id</strong> &#8211; int 
Index of the current element in the set of lines</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">node_coor: 
Array with coordinates of coordinate node. 
If the element is 3 node then array is 2*3
If it is a 2 node element then 2*2.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">local_newman</tt><big>(</big><em>q</em>, <em>nodes</em>, <em>newman</em>, <em>tag</em>, <em>ln</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines.local_newman"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Method used for the computation of the local Newman vector.</p>
<p>Returns the nodal values for a certain newman boundary line 
element by using the specific definition from the.bc file.</p>
<p>The Newman vector is constructed in order to define Newman boundary
conditions. It uses interpolation functions of line elements
and numerical integration to perform the calculation of components
q of the newman vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>q</strong> &#8211; Seems to be doing nothing, but I&#8217;m not removing it because 
there is no time to track a point from where it might be being 
invoqued.</li>
<li><strong>nodes</strong> &#8211; numpy.array
Array of coordinates for nodes, as read from the .msh file-</li>
<li><strong>newman</strong> &#8211; dict Boundaries.newman
dictionary that holds the information about what values or
expressions are assigned to a particular newmann bc.</li>
<li><strong>tag</strong> &#8211; str
id of the current boundary condition. dict newman may contain 
more than one relation, and tag is an identifier for selecting
one.</li>
<li><strong>vectorial</strong> &#8211; Boolean
Tells if the local vector is initiated to fit vectorial elements.
vectorial = True, builds two dof for each node in the element.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parama ln:</th><td class="field-body"><p class="first last">int
index of the current line element.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">numeric_J</tt><big>(</big><em>node_coords</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Lines.numeric_J"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Calculation of the Jacobian of a line element</p>
<p>Jacobian is used for scaling of arbitrary line elements into the
isoparametric line defined by interpolation functions h.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_coords</strong> &#8211; numpy.array
Array containing coordinates of nodes in the line. As extracted 
using method Lines.extract_el_points().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">J
Jacobian of the input matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Nodes</tt><a class="reference internal" href="_modules/Classes.html#Nodes"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Nodes, is a class that has coordinates for each node in a FE model.</p>
<p>Nodes, is an instance for handling nodes. Right now its only 
two attributes are the total number of nodes and the array of 
coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; int
Total number of nodes.</li>
<li><strong>coords</strong> &#8211; numpy.array
raw set of nodes as read from the mesh file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="Classes.Quadrilaterals">
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Quadrilaterals</tt><big>(</big><em>raw_quads</em>, <em>vectorial=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Quadrilaterals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Quadrilaterals" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for Quadrilateral elements and their methods.</p>
<p>QUAD elements are used for meshing 2D plane surfaces, and solving 
for the unknowns inside a region of the domain.
The quad elements supported here are  bi-linear or bi-cuadratic 
isoparametric elements of 8 nodes. They are best known as serendipity
elements.
Quadrilateral elements give better accuracy and resistance to 
locking than triangular elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>el_set</strong> &#8211; numpy.array
Has the tags and list of nodes for each line element.</li>
<li><strong>n_elements</strong> &#8211; int
number of quads in el_set</li>
<li><strong>order</strong> &#8211; int
Tells of what order the elements are. Order = 0 stands for
linear interpolation functions and order = 2 for cuadratic elements.
Maximum order is 2.</li>
<li><strong>h</strong> &#8211; list of lambda functions
Is a list where interpolation functions for each node of the element
are defined. h depends on the order of the element.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Classes.Quadrilaterals.build_local_stiffness">
<tt class="descname">build_local_stiffness</tt><big>(</big><em>nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Quadrilaterals.build_local_stiffness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Quadrilaterals.build_local_stiffness" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>This function calculates the local stiffness matrix for a </dt>
<dd><blockquote class="first">
<div>quad element using Gauss Legendre   quadratures as means for 
integration.
It returns a matrix that gets added to the global stiffness matrix.</div></blockquote>
<dl class="last docutils">
<dt>Parameters:</dt>
<dd>nodes:  Array of nodes, attribute node_coord from class Nodes()
el_id: Integer that points to a certain element in the el_set</dd>
<dt>output: </dt>
<dd><dl class="first last docutils">
<dt>lo_stiff: Array defining the local stiffness matrix of the problem</dt>
<dd><dl class="first last docutils">
<dt>given by:</dt>
<dd>[integrate_Omega</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>abla^2mathbf{E} mathbf{E} dOmega = integrate_Gamma mathbf{W}cdot (gradmathbf{E}cdot hat{n})dGamma</dt>
<dd><ul class="first last simple">
<li>integrate_Omega</li>
</ul>
</dd>
</dl>
<p>ablamathbf{E} : 
ablamathbf{W} dOmega  ]</p>
</dd></dl>

<dl class="method">
<dt id="Classes.Quadrilaterals.extract_el_points">
<tt class="descname">extract_el_points</tt><big>(</big><em>_nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Quadrilaterals.extract_el_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Quadrilaterals.extract_el_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for the extracion of coordinates from nodes in a element.</p>
<p>Extracts the coordinates of the nodes in each quad element and
retrieves an array of node coordinates.</p>
<p>loops inside an element reading the indexes of nodes and looks
for their coordinates in the matrix of nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nodes</strong> &#8211; numpy.array 
Of dimension (n_nodes, 3), where n_nodes is the 
number of nodes forming the mesh, and the three columns 
represent coordinates (x, y, z).</li>
<li><strong>el_id</strong> &#8211; int 
Index of the current element in the set of lines</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">node_coords: 
Array with coordinates of current node. 
If the element is 8 node then array is 2*8
If it is a 4 node element then 2*4.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Classes.Quadrilaterals.local_mass_matrix">
<tt class="descname">local_mass_matrix</tt><big>(</big><em>nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Quadrilaterals.local_mass_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Quadrilaterals.local_mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the local matrix for a quad element using
Gauss Legendre   quadratures as means for integration.
It returns a matrix that gets added to the global mass matrix.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd>nodes:  Array of nodes, attribute node_coord from class Nodes()
el_id: Integer that points to a certain element in the el_set</dd>
<dt>output: </dt>
<dd><dl class="first last docutils">
<dt>lo_mass: Array defining the local mass matrix of the problem</dt>
<dd><dl class="first last docutils">
<dt>given by:</dt>
<dd>int_{Omega} H^T ar{ar{epsilon}} H det(J) d Omega_{el}</dd>
<dt>Where H = interpolation functions according to whether</dt>
<dd>the formulation of the problem is scalar or vectorial</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Classes.Quadrilaterals.local_potential_matrix">
<tt class="descname">local_potential_matrix</tt><big>(</big><em>nodes</em>, <em>v</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Quadrilaterals.local_potential_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Quadrilaterals.local_potential_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the local potential matrix for a QUAD element using Gauss Legendre   quadratures as means for 
integration.</p>
<p>It returns a matrix that gets added to the global mass matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first">nodes:  Array of nodes, attribute node_coord from class Nodes()
v:     Potential is a vector that contains values for field</p>
<blockquote>
<div><p>parameters such as gravitational forces in</p>
</div></blockquote>
<p>el_id: Integer that points to a certain element in the el_set</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>lo_mass: Array defining the local mass matrix of the problem</dt>
<dd><dl class="first last docutils">
<dt>given by:</dt>
<dd><p class="first last">int_{Omega} H^T ar{ar{epsilon}} H det(J) 
d Omega_{el}</p>
</dd>
<dt>Where H = interpolation functions according to whether</dt>
<dd><p class="first last">the formulation of the problem is scalar or vectorial</p>
</dd>
</dl>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Classes.Quadrilaterals.numeric_J">
<tt class="descname">numeric_J</tt><big>(</big><em>node_coords</em>, <em>r</em>, <em>s</em>, <em>dHdrs=False</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Quadrilaterals.numeric_J"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Classes.Quadrilaterals.numeric_J" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of the Jacobian of a QUAD element</p>
<p>Determinant of the Jacobian matrix is used for scaling of arbitrary 
QUAD elements into the isoparametric element defined by 
interpolation functions h.
Also, the inverse of the Jacobian is used in the calculation of 
the gradient of isoparametric interpolation functions.
Right now, only the jacobian of second order QUAD elements is 
avaialble for solution.
The interpolation functions are derivated for coordinates r and s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_coords</strong> &#8211; numpy.array
Array containing coordinates of nodes in the line. As extracted 
using method Quadrilaterals.extract_el_points().</li>
<li><strong>dHdrs</strong> &#8211; Boolean
If you want the matrix array([dhdr,dhds]) returned, give this as 
True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters :</th><td class="field-body"><dl class="first docutils">
<dt>r: x coordinate of an integration point in Gauss-Legendre </dt>
<dd><p class="first last">cuadrature</p>
</dd>
<dt>s: x coordinate of an integration point in Gauss-Legendre </dt>
<dd><p class="first last">cuadrature</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">J_mat
Jacobian matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Region</tt><big>(</big><em>tag=''</em>, <em>name=''</em>, <em>material_prop={}</em>, <em>elements={}</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Region"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reperesents a region of the Domain.</p>
<p>It is a way to store attributes that are specific to certain regions 
of the simulation such as the kind of elements that compose it, 
it&#8217;s distinctive tag, and material properties.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Simulation</tt><a class="reference internal" href="_modules/Classes.html#Simulation"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Contains the data of a simulation.</p>
<p>Instances from this class act as a container for the overal 
problem definition of the simulation.
A simulation instance is meant to contain information about:</p>
<blockquote>
<div><ul class="simple">
<li>The domain and its discretized representation.</li>
<li>The physics of the problem.</li>
<li>Details about the method of solution.</li>
</ul>
</div></blockquote>
<p>After instantiating a simulationone one gets an almost empty class.
In order to have an useful object, you have to read the input
data from a .msh that hasbeen prepared beforehand in the preprocessing
stage.</p>
<p>To read information of a file use the method read_solver_input()</p>
<p>&#64;ivar domain:  The Domain and its discretization.
&#64;ivar sim_type: 
&#64;ivar dimension: 
&#64;ivar time_dependency:</p>
<dl class="method">
<dt>
<tt class="descname">read_solver_input</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Simulation.read_solver_input"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reads the solver input from a file of gmsh ASCII format V2.2.</p>
<p>This input is to be read by the Solver module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; String 
which contain filename and path of the output file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">solver_input
List with the following parameters:
[dimension, bc_type, parameter, eq, sol_type, analysis_param]</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>dimension: int </dt>
<dd>Parameter that tells the program wether to solve for a
1D problem or a 2D problem. 1D problems are currently 
not supported.</dd>
<dt>bc_type: str</dt>
<dd><p class="first">Parameter for the selection of a boundary condition
that can be either:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;Dir&#8217;:</dt>
<dd>For the Dirichlet border condition
(Infinite potential well).</dd>
<dt>&#8216;Bloch&#8217;:</dt>
<dd>For the periodic formulation of the problem.
(Electron in a periodic material )</dd>
</dl>
</div></blockquote>
</dd>
<dt>body_parameter: numpy.array</dt>
<dd><p class="first">Is an array that describes the body force actuating over the
the elements of the domain. 
For each element in self.domain.elements
there is an associated potential value on the same
position in the array parameter. For EM this fiel is empty.</p>
<p class="last">The potential in Scroedinger equation defines the specific
nature of the problem to be solved. For more details on how
to define a potential and what does it mean please read the
documentation of the Potential1D function in the module PrePro.</p>
</dd>
<dt>sim_type: str</dt>
<dd>Can be &#8216;QM&#8217; from Quantum Mechanics, or &#8216;EM&#8217; for 
electromagnetism.</dd>
<dt>sol_type:  str</dt>
<dd><p class="first">Tells wether to solve the stationary version of the equation 
or dynamic one</p>
<blockquote class="last">
<div><ul class="simple">
<li>&#8216;Stationary&#8217;</li>
<li>&#8216;Transient&#8217;</li>
</ul>
</div></blockquote>
</dd>
<dt>solver_param:  list </dt>
<dd><p class="first">Array that contains the information regarding the number
of solutions to be computed and wether to save the values
or not.
analysis_param[0]:  str</p>
<blockquote>
<div>answer to the question, Save  Eigen Values?</div></blockquote>
<dl class="last docutils">
<dt>analysis_param[1]:  str</dt>
<dd>answer to the question  Save  Eigen Vectors?</dd>
<dt>analysis_param[2]:  int</dt>
<dd>number of Eigen Values to save.</dd>
<dt>analysis_param[3]:  int</dt>
<dd>number of Eigen Vectors to save.</dd>
<dt>analysis_param[4]:  int</dt>
<dd>number of wave numbers in x to sweep</dd>
<dt>analysis_param[5]:  int</dt>
<dd>number of wave numbers in y to sweep</dd>
<dt>analysis_param[6]:  int-float</dt>
<dd>biggest value of k. it may be the lenght of the dommain</dd>
</dl>
</dd>
<dt>bc_filename: str</dt>
<dd>tells where to look for the boundary conditions</dd>
</dl>
<p>Last modification: date 05/05/2013</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">Classes.</tt><tt class="descname">Triangles</tt><big>(</big><em>raw_triangles</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Triangles class is a container for triangular elements and their 
common methods.</p>
<p>Triangular elements are best suited for representing curved boundaries
and edges.</p>
<p>Triangles are one kind of very important elements</p>
<dl class="method">
<dt>
<tt class="descname">calc_area</tt><big>(</big><em>lines</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles.calc_area"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Calculates the area of a triangle by using Heron&#8217;s theorem</p>
<p>line:  list of 3 2D arrays. Defines line segments of the triangle</p>
<p>area:  float number.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">extract_el_edges</tt><big>(</big><em>points</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles.extract_el_edges"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Receive the list of points given by &#8220;extract_el_points&#8221; and return 
a list of line segments from which the area can be calculated</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">extract_el_points</tt><big>(</big><em>_nodes</em>, <em>el_id</em><big>)</big><a class="reference internal" href="_modules/Classes.html#Triangles.extract_el_points"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Extracts the coordinates of the nodes in each triangular element and
retrieves each vertice as a vector of two dimensions.</p>
<dl class="docutils">
<dt>nodes:  numpy array of dimension (n_nodes, 3), where n_nodes is the </dt>
<dd>number of nodes forming the mesh, and the three columns 
represent coordinates (x, y, z).</dd>
<dt>triangles:  numpy array of dimension (n_triangles, 4), where n_nodes </dt>
<dd>is the number of nodes forming the mesh, the first is the 
label that refers to the physical entity where each node 
belongs. The remaining columns  tell which nodes belong
to each of the vertices of the triangle.</dd>
</dl>
<p>el:   integer value of the current element</p>
<dl class="docutils">
<dt>pt_a, pt_b, pt_c:  vector like array of two dimensions where the first </dt>
<dd>is the position in x, and the second is the position 
of the node in y.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Documentation for Module Classes.py</a><ul>
<li><a class="reference internal" href="#list-of-classes">List of Classes</a><ul>
<li><a class="reference internal" href="#simulation">Simulation()</a></li>
<li><a class="reference internal" href="#domain">Domain()</a></li>
<li><a class="reference internal" href="#region">Region()</a></li>
<li><a class="reference internal" href="#nodes">Nodes()</a></li>
<li><a class="reference internal" href="#elements">Elements()</a></li>
<li><a class="reference internal" href="#lines">Lines()</a></li>
<li><a class="reference internal" href="#triangles">Triangles()</a></li>
<li><a class="reference internal" href="#quadrilaterals">Quadrilaterals()</a></li>
<li><a class="reference internal" href="#boundaries">Boundaries()</a></li>
<li><a class="reference internal" href="#dof">DOF()</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="code.html"
                        title="previous chapter">Documentation for the code</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Interpreter.html"
                        title="next chapter">Documentation for Module Interpreter.py</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/Classes.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Interpreter.html" title="Documentation for Module Interpreter.py"
             >next</a> |</li>
        <li class="right" >
          <a href="code.html" title="Documentation for the code"
             >previous</a> |</li>
        <li><a href="index.html">peyeQM 1.0 documentation</a> &raquo;</li>
          <li><a href="code.html" >Documentation for the code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Santiago Echeverri, Nicolás Guarín, Edward Villegas.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>