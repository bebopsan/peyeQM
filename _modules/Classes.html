

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classes &mdash; peyeQM 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="peyeQM 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">peyeQM 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for Classes</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; Classes module specifications.</span>

<span class="sd">Module Classes holds many of the classes used by PeYeQM to</span>
<span class="sd">define the instances necessary for the initial statement</span>
<span class="sd">of a simulation problem.</span>

<span class="sd">List of Classes</span>
<span class="sd">===============</span>

<span class="sd">Simulation()</span>
<span class="sd">------------</span>
<span class="sd">Top level class of a FEA. It contains as attributes all other classes listed </span>
<span class="sd">below.</span>
<span class="sd">It has</span>
<span class="sd">    - Definition of the problem. </span>
<span class="sd">    - Details about the context of the solution.</span>
<span class="sd">Domain()</span>
<span class="sd">--------</span>
<span class="sd">Representation of the physical domain of a simulation. </span>
<span class="sd">It has:</span>
<span class="sd">    - Information about regions and their discretization</span>
<span class="sd">    - definitions of elements, nodes and boundary conditions</span>

<span class="sd">Region()</span>
<span class="sd">--------</span>
<span class="sd">A region is an object that allows the identification of different material </span>
<span class="sd">properties according to a previous subdivision of the Domain.</span>

<span class="sd">Nodes()</span>
<span class="sd">-------</span>
<span class="sd">Class Nodes represents the coordinates of the points that result from </span>
<span class="sd">a discretization of a given domain. </span>

<span class="sd">Elements()</span>
<span class="sd">----------</span>
<span class="sd">Class elements is a container for sets of 1D and 2D elements that can be </span>
<span class="sd">of different shapes and orders. Elements are representations of the </span>
<span class="sd">relation between nodes of a discretized domain.  </span>
<span class="sd">Current supported elements are:</span>
<span class="sd">    - Lines</span>
<span class="sd">    - Triangles</span>
<span class="sd">    - Quadrilaterals</span>
<span class="sd">Lines()</span>
<span class="sd">-------</span>
<span class="sd">An instance of class Lines() is a container of line elements. </span>
<span class="sd">This class also defines common operations and attributes that </span>
<span class="sd">involve line elements.</span>

<span class="sd">Triangles()</span>
<span class="sd">-----------</span>
<span class="sd">An instance of class Triangles() is a container of triangular elements. </span>
<span class="sd">This class also defines common operations and attributes that </span>
<span class="sd">involve triangular elements.</span>

<span class="sd">Quadrilaterals()</span>
<span class="sd">----------------</span>
<span class="sd">An instance of class Quadrilaterals() is a container of QUAD elements. </span>
<span class="sd">This class also defines common operations and attributes that </span>
<span class="sd">involve QUAD elements.</span>

<span class="sd">Boundaries()</span>
<span class="sd">------------</span>
<span class="sd">This class acts as a container of boundaries and their attributes.</span>
<span class="sd">Boundaries of a domain are the objects where edge conditions are stated.</span>

<span class="sd">DOF()</span>
<span class="sd">-----</span>
<span class="sd">DOF is a class that was defined for transient simulations only.</span>
<span class="sd">A DOF represents a degree of freedom in a dynamic problem, and has the </span>
<span class="sd">necessary attributes and methods for a time dependant algorithm</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Santiago Echeverri Chac√≥n&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Simulation"><a class="viewcode-back" href="../Classes.html#Classes.Simulation">[docs]</a><span class="k">class</span> <span class="nc">Simulation</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Contains the data of a simulation.</span>
<span class="sd">    </span>
<span class="sd">    Instances from this class act as a container for the overal </span>
<span class="sd">    problem definition of the simulation.</span>
<span class="sd">    A simulation instance is meant to contain information about:</span>
<span class="sd">        - The domain and its discretized representation.</span>
<span class="sd">        - The physics of the problem.</span>
<span class="sd">        - Details about the method of solution.</span>
<span class="sd">    After instantiating a simulationone one gets an almost empty class.</span>
<span class="sd">    In order to have an useful object, you have to read the input</span>
<span class="sd">    data from a .msh that hasbeen prepared beforehand in the preprocessing</span>
<span class="sd">    stage. </span>
<span class="sd">    </span>
<span class="sd">    To read information of a file use the method read_solver_input()</span>
<span class="sd">    </span>
<span class="sd">    @ivar domain:  The Domain and its discretization.</span>
<span class="sd">    @ivar sim_type: </span>
<span class="sd">    @ivar dimension: </span>
<span class="sd">    @ivar time_dependency:</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Not really a proper __init__ function. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">()</span>
    <span class="n">sim_type</span> <span class="o">=</span> <span class="s">&#39;QM&#39;</span>
    <span class="n">time_dependency</span> <span class="o">=</span> <span class="s">&#39;Stationary&#39;</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;This is an instance of the Simulation Class&#39;</span>
        
<div class="viewcode-block" id="Simulation.read_solver_input"><a class="viewcode-back" href="../Classes.html#Classes.Simulation.read_solver_input">[docs]</a>    <span class="k">def</span> <span class="nf">read_solver_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the solver input from a file of gmsh ASCII format V2.2.</span>
<span class="sd">        </span>
<span class="sd">        This input is to be read by the Solver module.</span>
<span class="sd">        </span>
<span class="sd">        :param filename: String </span>
<span class="sd">            which contain filename and path of the output file.</span>
<span class="sd">       </span>
<span class="sd">        :returns: solver_input</span>
<span class="sd">            List with the following parameters:</span>
<span class="sd">            [dimension, bc_type, parameter, eq, sol_type, analysis_param]</span>
<span class="sd">    </span>
<span class="sd">        dimension: int </span>
<span class="sd">            Parameter that tells the program wether to solve for a</span>
<span class="sd">            1D problem or a 2D problem. 1D problems are currently </span>
<span class="sd">            not supported.</span>
<span class="sd">        bc_type: str</span>
<span class="sd">            Parameter for the selection of a boundary condition</span>
<span class="sd">            that can be either:</span>
<span class="sd">                &#39;Dir&#39;:</span>
<span class="sd">                    For the Dirichlet border condition</span>
<span class="sd">                    (Infinite potential well).</span>
<span class="sd">                &#39;Bloch&#39;:</span>
<span class="sd">                    For the periodic formulation of the problem.</span>
<span class="sd">                    (Electron in a periodic material )</span>
<span class="sd">        body_parameter: numpy.array</span>
<span class="sd">            Is an array that describes the body force actuating over the</span>
<span class="sd">            the elements of the domain. </span>
<span class="sd">            For each element in self.domain.elements</span>
<span class="sd">            there is an associated potential value on the same</span>
<span class="sd">            position in the array parameter. For EM this fiel is empty.</span>
<span class="sd">    </span>
<span class="sd">            The potential in Scroedinger equation defines the specific</span>
<span class="sd">            nature of the problem to be solved. For more details on how</span>
<span class="sd">            to define a potential and what does it mean please read the</span>
<span class="sd">            documentation of the Potential1D function in the module PrePro.</span>

<span class="sd">        sim_type: str</span>
<span class="sd">            Can be &#39;QM&#39; from Quantum Mechanics, or &#39;EM&#39; for </span>
<span class="sd">            electromagnetism.</span>
<span class="sd">        sol_type:  str</span>
<span class="sd">            Tells wether to solve the stationary version of the equation </span>
<span class="sd">            or dynamic one</span>
<span class="sd">                - &#39;Stationary&#39;   </span>
<span class="sd">                - &#39;Transient&#39;</span>
<span class="sd">        solver_param:  list </span>
<span class="sd">            Array that contains the information regarding the number</span>
<span class="sd">            of solutions to be computed and wether to save the values</span>
<span class="sd">            or not.</span>
<span class="sd">            analysis_param[0]:  str</span>
<span class="sd">                answer to the question, Save  Eigen Values?</span>
<span class="sd">            analysis_param[1]:  str</span>
<span class="sd">                answer to the question  Save  Eigen Vectors?</span>
<span class="sd">            analysis_param[2]:  int</span>
<span class="sd">                number of Eigen Values to save.</span>
<span class="sd">            analysis_param[3]:  int</span>
<span class="sd">                number of Eigen Vectors to save. </span>
<span class="sd">            analysis_param[4]:  int</span>
<span class="sd">                number of wave numbers in x to sweep</span>
<span class="sd">            analysis_param[5]:  int</span>
<span class="sd">                number of wave numbers in y to sweep</span>
<span class="sd">            analysis_param[6]:  int-float</span>
<span class="sd">                biggest value of k. it may be the lenght of the dommain                                        </span>
<span class="sd">        bc_filename: str</span>
<span class="sd">            tells where to look for the boundary conditions  </span>
<span class="sd">                            </span>
<span class="sd">        Last modification: date 05/05/2013</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">read_mesh</span> <span class="kn">import</span> <span class="n">read_solver_input</span>
        <span class="n">solver_input</span> <span class="o">=</span> <span class="n">read_solver_input</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">solver_input</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_type</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">body_parameter</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>                <span class="c"># Reasign</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_type</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_dependency</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_param</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>         <span class="c"># the solution </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_filename</span> <span class="o">=</span> <span class="n">solver_input</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Pending implementation&#39;</span><span class="p">)</span>
    
</div></div>
<div class="viewcode-block" id="Domain"><a class="viewcode-back" href="../Classes.html#Classes.Domain">[docs]</a><span class="k">class</span> <span class="nc">Domain</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Is a container to other classes and methods exclusive of the domain.</span>
<span class="sd">    </span>
<span class="sd">    Instances from Domain Class contain the attributes that define </span>
<span class="sd">    characteristics of the simulation such as regions, meshing, and </span>
<span class="sd">    boundary conditions. They are somehow independent of the details</span>
<span class="sd">    regarding the solution of the problem. </span>
<span class="sd">    </span>
<span class="sd">    A domain is one of the principal components of the Simulation Class.</span>
<span class="sd">    To be included here are instances of clases such as:</span>
<span class="sd">        - Regions.</span>
<span class="sd">        - Nodes.</span>
<span class="sd">        - Elements. </span>
<span class="sd">        - Boundaries.</span>
<span class="sd">    These are the main attibutes of a domain in Finite Elemen Analysis.</span>
<span class="sd">    </span>
<span class="sd">    :ivar nodes: Nodes()</span>
<span class="sd">        After discretization space is reduced to points known as nodes,</span>
<span class="sd">        each having unique coordinates. Nodes, is a class that contains</span>
<span class="sd">        the coordinates of each node. for a FE model.</span>

<span class="sd">    :ivar elements: Elements()</span>
<span class="sd">        The way in which FEA solves problems is by solving differential </span>
<span class="sd">        equations over chunks of the domain. These chunks are called </span>
<span class="sd">        elements, and as the name suggest they are characterized by being</span>
<span class="sd">        finite. By defining these elements as simple interpolation </span>
<span class="sd">        function of nodes, one can create an approximate representation </span>
<span class="sd">        of space and solve the differential equations for these functions.</span>
<span class="sd">        elements is an instance that contains information about the elemens</span>
<span class="sd">        that form the domain.</span>
<span class="sd">        </span>
<span class="sd">    :ivar regions: list [ Region1, Region2 ]</span>
<span class="sd">        regions is a list of instances of class region which will help </span>
<span class="sd">        us relate material properties with different sets of elements. </span>
<span class="sd">    </span>
<span class="sd">    :ivar boundaries: Boundaries()</span>
<span class="sd">        As in any situation where one has to solve differential equations,</span>
<span class="sd">        in FEA particular conditions have to be stated in some boundaries</span>
<span class="sd">        of the domain in order to have unique solutions.</span>
<span class="sd">        This instance has information about which boundaries have </span>
<span class="sd">        boundary conditions that are relevant to the solution of the </span>
<span class="sd">        simulation.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This init is not very usefull. Maybe it shouldnt be there&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="p">{}</span>
        
<div class="viewcode-block" id="Domain.read_mesh_file"><a class="viewcode-back" href="../Classes.html#Classes.Domain.read_mesh_file">[docs]</a>    <span class="k">def</span> <span class="nf">read_mesh_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">vectorial</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads mesh characteristics from a .msh file of gmsh</span>
<span class="sd">            ASCII format V2.2.</span>
<span class="sd">        </span>
<span class="sd">        This method is meant to populate a domain instance by reading</span>
<span class="sd">        nodes and elements from a .msh file.   </span>
<span class="sd">        - Instances from Nodes and Elements are created.</span>
<span class="sd">        - Function read_mesh() from module read_mesh.py is used to extract </span>
<span class="sd">          raw sets of elements and nodes.</span>
<span class="sd">        - raw sets are added to nodes and elements by using their method </span>
<span class="sd">          add()</span>
<span class="sd">        </span>
<span class="sd">        :param filename: str </span>
<span class="sd">            which contains path and filename of input .msh file.</span>
<span class="sd">        :keyord vectorial: Boolean</span>
<span class="sd">            Tells if the problem is to be solved with a scalar or vectorial </span>
<span class="sd">            formulation. vectorial = True, builds two unknowns for each node.</span>
<span class="sd">                    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">read_mesh</span> <span class="kn">import</span> <span class="n">read_mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">Elements</span><span class="p">()</span>
        <span class="n">_nodes</span><span class="p">,</span> <span class="n">_elements</span> <span class="o">=</span> <span class="n">read_mesh</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_elements</span><span class="p">,</span> <span class="n">vectorial</span><span class="p">)</span></div>
<div class="viewcode-block" id="Domain.read_regions_file"><a class="viewcode-back" href="../Classes.html#Classes.Domain.read_regions_file">[docs]</a>    <span class="k">def</span> <span class="nf">read_regions_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads Region attributes from a .reg file exported by pickle.</span>
<span class="sd">        </span>
<span class="sd">        This method is meant to populate a domain instance by reading</span>
<span class="sd">        regions attributes from a .reg file.   </span>
<span class="sd">        The .reg file is a list of instances of class Region() that has </span>
<span class="sd">        been exported by using python&#39;s pickle function.</span>
<span class="sd">        A .reg file contains elements, material properties, and a tag.</span>

<span class="sd">        - Import the list        </span>
<span class="sd">        - For each region in the list, add the elemtns that have its tag</span>
<span class="sd">          by deep-copying them.</span>
<span class="sd">        </span>
<span class="sd">        :param filename: str </span>
<span class="sd">            which contains path and filename of input .reg file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">delete</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
        <span class="kn">import</span> <span class="nn">pickle</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span><span class="s">&#39;.reg&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">:</span>
            <span class="n">region</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">class_iter</span> <span class="ow">in</span> <span class="n">region</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">remove</span> <span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">region</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">class_iter</span><span class="p">]</span><span class="o">.</span><span class="n">el_set</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
                        <span class="n">remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">el_set</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">class_iter</span><span class="p">]</span><span class="o">.</span><span class="n">el_set</span><span class="p">,</span> <span class="n">remove</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">region</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">class_iter</span><span class="p">]</span><span class="o">.</span><span class="n">el_set</span> <span class="o">=</span> <span class="n">el_set</span>
                <span class="n">region</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">class_iter</span><span class="p">]</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">=</span> <span class="n">el_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>
            </div>
<div class="viewcode-block" id="Domain.read_bc_file"><a class="viewcode-back" href="../Classes.html#Classes.Domain.read_bc_file">[docs]</a>    <span class="k">def</span> <span class="nf">read_bc_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads boundary confitions attributes from a .bc file.</span>
<span class="sd">            </span>
<span class="sd">        .bc files are made by hand by the user, and by means of tags</span>
<span class="sd">        relate line elements to pre-established values.</span>
<span class="sd">        There are three kinds of boundary conditions</span>
<span class="sd">        D: Dirichlet</span>
<span class="sd">            Conditions where one knows the value of the solution at the node.</span>
<span class="sd">        N: Newman</span>
<span class="sd">            Conditions where one knows the value of the derivative</span>
<span class="sd">            of the  solution at the node.</span>
<span class="sd">        B: Bloch</span>
<span class="sd">            Made for Bloch periodicity</span>

<span class="sd">        :param filename: str </span>
<span class="sd">            which contains path and filename of input .bc file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">read_mesh</span> <span class="kn">import</span> <span class="n">read_bc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span> <span class="o">=</span> <span class="n">Boundaries</span><span class="p">()</span>
        <span class="n">_bc</span> <span class="o">=</span> <span class="n">read_bc</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_bc</span><span class="p">)</span>                
                  </div></div>
<div class="viewcode-block" id="Nodes"><a class="viewcode-back" href="../Classes.html#Classes.Nodes">[docs]</a><span class="k">class</span> <span class="nc">Nodes</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Nodes, is a class that has coordinates for each node in a FE model.</span>
<span class="sd">    </span>
<span class="sd">    Nodes, is an instance for handling nodes. Right now its only </span>
<span class="sd">    two attributes are the total number of nodes and the array of </span>
<span class="sd">    coordinates.</span>
<span class="sd">    </span>
<span class="sd">    :ivar n: int</span>
<span class="sd">        Total number of nodes.</span>
<span class="sd">    :ivar coords: numpy.array</span>
<span class="sd">        raw set of nodes as read from the mesh file.       </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># def __init__(self):</span>
        
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_nodes</span><span class="p">):</span>        
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">_nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>                 <span class="c">#Number of nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">_nodes</span>        
    </div>
<div class="viewcode-block" id="Region"><a class="viewcode-back" href="../Classes.html#Classes.Region">[docs]</a><span class="k">class</span> <span class="nc">Region</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Reperesents a region of the Domain.</span>
<span class="sd">    </span>
<span class="sd">    It is a way to store attributes that are specific to certain regions </span>
<span class="sd">    of the simulation such as the kind of elements that compose it, </span>
<span class="sd">    it&#39;s distinctive tag, and material properties.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">material_prop</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">elements</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; Initialization of a region.</span>
<span class="sd">        </span>
<span class="sd">        :keyword tag: str</span>
<span class="sd">            This is a str that has a number. The number must be associated</span>
<span class="sd">            to a physical surface of the mesh. Using this value one can</span>
<span class="sd">            extract elements from the raw list of elements and assign them</span>
<span class="sd">            to a particular region defined by this instance.</span>
<span class="sd">        :keyword name: str</span>
<span class="sd">            If you want to name this region for any reason </span>
<span class="sd">        :keyword material_prop: dict</span>
<span class="sd">            dictionary, that lists the properties and their values. One </span>
<span class="sd">            example for the EM simulation is to define permitivity and </span>
<span class="sd">            permeability:</span>
<span class="sd">                material_prop = {&#39;epsilon&#39;:8.9, &#39;mu&#39;:1.0}</span>
<span class="sd">        :keyword elements: dict of numpy.array&#39;s</span>
<span class="sd">            This dictionary contains all the elements of a simulation</span>
<span class="sd">            that are related to self.tag. This dict gets filled with</span>
<span class="sd">            method domain.read_regions_file() </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_prop</span> <span class="o">=</span>  <span class="n">material_prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Region with tag </span><span class="si">%s</span><span class="s"> is called </span><span class="si">%s</span><span class="s"> and has the following&quot;</span>\
                <span class="s">&quot;material properties: </span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s"> and sets of elements </span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span>\
                <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_prop</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    </div>
<div class="viewcode-block" id="Elements"><a class="viewcode-back" href="../Classes.html#Classes.Elements">[docs]</a><span class="k">class</span> <span class="nc">Elements</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Contains information about all elemens that form the domain.</span>
<span class="sd">    </span>
<span class="sd">    Elements is a class that gets filled by interpreting an array of </span>
<span class="sd">    raw elements, instantiating objects of the relevant class for </span>
<span class="sd">    each elemnt.</span>
<span class="sd">    </span>
<span class="sd">    If the reading of a .msh file gives line and quad elements, they are</span>
<span class="sd">    saved into instances of classes Line() and Quadrilateral().</span>
<span class="sd">    </span>
<span class="sd">    :ivar all: dict of elements</span>
<span class="sd">        all is a dictionary where all kinds of elements are indexed    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all</span> <span class="o">=</span> <span class="p">{}</span>
<div class="viewcode-block" id="Elements.add"><a class="viewcode-back" href="../Classes.html#Classes.Elements.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_elements</span><span class="p">,</span> <span class="n">vectorial</span><span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Function to populate the class by interpreting a dict of elements.</span>
<span class="sd">        </span>
<span class="sd">        :param _elements: dict of elements</span>
<span class="sd">        :keyword vectorial: Boolean</span>
<span class="sd">            Tells if the elements are instantiated as vectorial elements.</span>
<span class="sd">            vectorial = True, builds bigger matrices.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;lin_Lines&#39;</span> <span class="ow">in</span> <span class="n">_elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">Lines</span><span class="p">(</span><span class="n">_elements</span><span class="p">[</span><span class="s">&#39;lin_Lines&#39;</span><span class="p">],</span> <span class="n">vectorial</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all</span><span class="p">[</span><span class="s">&#39;lin_Lines&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span>
        <span class="k">elif</span> <span class="s">&#39;cuad_Lines&#39;</span> <span class="ow">in</span> <span class="n">_elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">Lines</span><span class="p">(</span><span class="n">_elements</span><span class="p">[</span><span class="s">&#39;cuad_Lines&#39;</span><span class="p">],</span> <span class="n">vectorial</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all</span><span class="p">[</span><span class="s">&#39;cuad_Lines&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;No higher order line elements of more&quot;</span>\
                                        <span class="s">&quot;than second order. Maybe you did&#39;t&quot;</span>\
                                        <span class="s">&quot;define physical lines?&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;Triangles&#39;</span> <span class="ow">in</span> <span class="n">_elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span> <span class="o">=</span> <span class="n">Triangles</span><span class="p">(</span><span class="n">_elements</span><span class="p">[</span><span class="s">&#39;Triangles&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all</span><span class="p">[</span><span class="s">&#39;Triangles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles</span>
        <span class="k">if</span> <span class="s">&#39;cuad_Quads&#39;</span> <span class="ow">in</span> <span class="n">_elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quads</span> <span class="o">=</span> <span class="n">Quadrilaterals</span><span class="p">(</span><span class="n">_elements</span><span class="p">[</span><span class="s">&#39;cuad_Quads&#39;</span><span class="p">],</span> <span class="n">vectorial</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all</span><span class="p">[</span><span class="s">&#39;cuad_Quads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quads</span>
</div></div>
<div class="viewcode-block" id="Lines"><a class="viewcode-back" href="../Classes.html#Classes.Lines">[docs]</a><span class="k">class</span> <span class="nc">Lines</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Container for line elements and their methods.</span>
<span class="sd">    </span>
<span class="sd">    Line elements are used for solving 1D problems and handling </span>
<span class="sd">    boundary conditions. The instance lines has been made in order</span>
<span class="sd">    to contain properties that are defined exlusively for line elements</span>
<span class="sd">    such as stiffness matrices for 1D problems and</span>
<span class="sd">    interpolation methods for newman and source vectors.</span>
<span class="sd">    </span>
<span class="sd">    :ivar el_set: numpy.array</span>
<span class="sd">        Has the tags and list of nodes for each line element.</span>
<span class="sd">    :ivar n_elements: int</span>
<span class="sd">        number of lines in el_set</span>
<span class="sd">    :ivar order: int</span>
<span class="sd">        Tells of what order the elements are. order = 0 stands for</span>
<span class="sd">        linear interpolation functions and order = 2 for cuadratic lines.</span>
<span class="sd">        Maximum order is 2.</span>
<span class="sd">    :ivar h: list of lambda functions</span>
<span class="sd">        Is a list where interpolation functions for each node of the element</span>
<span class="sd">        are defined. h depends on the order of the element.</span>
<span class="sd">    </span>
<span class="sd">    What we are trying to obtain when solving a FE problem is a function </span>
<span class="sd">    that represents the solution of a certain equation. By using  Finite </span>
<span class="sd">    elements  we form an abstraction of that function. Defining smaller </span>
<span class="sd">    compact suport functions that represent chunks of the domain, and </span>
<span class="sd">    assembling them carefully, we can build an approximate solution </span>
<span class="sd">    of complex problems whose analytical solution is out of reach.</span>
<span class="sd">    </span>
<span class="sd">    These compact suport functions are stated as interpolation functions</span>
<span class="sd">    of nodal values and their relative positions. </span>
<span class="sd">    The idea is that knowing nodal values and the positions of nodes, </span>
<span class="sd">    we are able to interpolate the solution and find the value of an </span>
<span class="sd">    arbitrary point. It is however an approximation, and the precision</span>
<span class="sd">    of this value will be dependent of factors such as:</span>
<span class="sd">        - Number of nodes per element.</span>
<span class="sd">        - Order of the interpolation function.</span>
<span class="sd">        - complexity of the solution.</span>
<span class="sd">    </span>
<span class="sd">    In peyeQM elements are isoparametric elements. This means that </span>
<span class="sd">    elents of any shape are mapped to a standard element from which </span>
<span class="sd">    it is easier to perform operations.</span>
<span class="sd">    </span>
<span class="sd">    interpolation functions for the line element are:</span>
<span class="sd">    ..math::</span>
<span class="sd">        h_1 = \frac{1}{2}\left( 1 - r \right ) if cuad: </span>
<span class="sd">            - \frac{1}{2}\left( 1 - r^2 \right )</span>
<span class="sd">    ..math::</span>
<span class="sd">        h_2 = \frac{1}{2}\left( 1 + r \right )  if cuad: </span>
<span class="sd">        - \frac{1}{2}\left( 1 - r^2 \right )</span>
<span class="sd">    ..math::</span>
<span class="sd">        h_3 = \left( 1 - r  \right )</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_lines</span><span class="p">,</span> <span class="n">vectorial</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialization of a Lines object.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :param raw_lines: numpy.array</span>
<span class="sd">            Has the lines as extracted from function read_mesh_file()</span>
<span class="sd">            of module read_mesh.</span>
<span class="sd">        :keyword vectorial: Boolean</span>
<span class="sd">            Tells if the elements are instantiated as vectorial elements.</span>
<span class="sd">            vectorial = True, builds bigger matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span> <span class="o">=</span> <span class="n">raw_lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>            
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">),</span>\
                      <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>            
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>\
                      <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>\
                      <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Up to second order only&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span> <span class="o">=</span> <span class="n">vectorial</span>
<div class="viewcode-block" id="Lines.extract_el_points"><a class="viewcode-back" href="../Classes.html#Classes.Lines.extract_el_points">[docs]</a>    <span class="k">def</span> <span class="nf">extract_el_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method for the extracion of coordinates from nodes in a element.</span>
<span class="sd">        </span>
<span class="sd">        Extracts the coordinates of the nodes in each line element and</span>
<span class="sd">        retrieves an array of node coordinates.</span>
<span class="sd">        </span>
<span class="sd">        loops inside an element reading the indexes of nodes and looks</span>
<span class="sd">        for their coordinates in the matrix of nodes.</span>
<span class="sd">        </span>
<span class="sd">        :param nodes: numpy.array </span>
<span class="sd">            Of dimension (n_nodes, 3), where n_nodes is the </span>
<span class="sd">            number of nodes forming the mesh, and the three columns </span>
<span class="sd">            represent coordinates (x, y, z).</span>
<span class="sd">        :param el_id: int </span>
<span class="sd">            Index of the current element in the set of lines</span>
<span class="sd">        </span>
<span class="sd">        :returns: node_coor: </span>
<span class="sd">                Array with coordinates of coordinate node. </span>
<span class="sd">                If the element is 3 node then array is 2*3</span>
<span class="sd">                If it is a 2 node element then 2*2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
        <span class="k">if</span> <span class="s">&#39;el_set&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">p2_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span>   
                <span class="n">node_coords</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p2_lines</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p2_lines</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                   
                <span class="k">return</span> <span class="n">node_coords</span>   
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">p1_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span>                            
                <span class="n">node_coords</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_lines</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_lines</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">node_coords</span>   
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order elements yet, </span><span class="se">\</span>
<span class="s">                                           there must be an error&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;No elements parsed, do something else&#39;</span><span class="p">)</span></div>
<div class="viewcode-block" id="Lines.numeric_J"><a class="viewcode-back" href="../Classes.html#Classes.Lines.numeric_J">[docs]</a>    <span class="k">def</span> <span class="nf">numeric_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculation of the Jacobian of a line element</span>
<span class="sd">        </span>
<span class="sd">        Jacobian is used for scaling of arbitrary line elements into the</span>
<span class="sd">        isoparametric line defined by interpolation functions h.</span>
<span class="sd">        </span>
<span class="sd">        :param node_coords: numpy.array</span>
<span class="sd">            Array containing coordinates of nodes in the line. As extracted </span>
<span class="sd">            using method Lines.extract_el_points().</span>
<span class="sd">        :returns: J</span>
<span class="sd">            Jacobian of the input matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>     
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>             
            <span class="n">L1</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">L2</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">L1</span> <span class="o">+</span> <span class="n">L2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order elements yet, </span><span class="se">\</span>
<span class="s">                                           there must be an error&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">J</span></div>
<div class="viewcode-block" id="Lines.local_newman"><a class="viewcode-back" href="../Classes.html#Classes.Lines.local_newman">[docs]</a>    <span class="k">def</span> <span class="nf">local_newman</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">newman</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span> <span class="n">vectorial</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method used for the computation of the local Newman vector.</span>
<span class="sd">        </span>
<span class="sd">        Returns the nodal values for a certain newman boundary line </span>
<span class="sd">        element by using the specific definition from the.bc file.</span>
<span class="sd">        </span>
<span class="sd">        The Newman vector is constructed in order to define Newman boundary</span>
<span class="sd">        conditions. It uses interpolation functions of line elements</span>
<span class="sd">        and numerical integration to perform the calculation of components</span>
<span class="sd">        q of the newman vector.</span>
<span class="sd">        </span>
<span class="sd">        :param q: Seems to be doing nothing, but I&#39;m not removing it because </span>
<span class="sd">            there is no time to track a point from where it might be being </span>
<span class="sd">            invoqued.</span>
<span class="sd">        :param nodes: numpy.array</span>
<span class="sd">            Array of coordinates for nodes, as read from the .msh file-</span>
<span class="sd">        :param newman: dict Boundaries.newman</span>
<span class="sd">            dictionary that holds the information about what values or</span>
<span class="sd">            expressions are assigned to a particular newmann bc.</span>
<span class="sd">        :param tag: str</span>
<span class="sd">            id of the current boundary condition. dict newman may contain </span>
<span class="sd">            more than one relation, and tag is an identifier for selecting</span>
<span class="sd">            one.</span>
<span class="sd">        :parama ln: int</span>
<span class="sd">            index of the current line element.</span>
<span class="sd">        :keyword vectorial: Boolean</span>
<span class="sd">            Tells if the local vector is initiated to fit vectorial elements.</span>
<span class="sd">            vectorial = True, builds two dof for each node in the element.    </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bc_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span>
        <span class="n">nodes_line</span> <span class="o">=</span> <span class="n">bc_lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.special.orthogonal</span> <span class="kn">import</span> <span class="n">p_roots</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
            <span class="n">h3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span>
             <span class="c"># Definition of integration degree for each of the coordinates</span>
            <span class="n">deg_r</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">weights_r</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_r</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                <span class="n">lo_q</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">bc_lines</span><span class="p">[</span><span class="n">ln</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nodes_line</span><span class="p">]:</span>
                    <span class="n">xvalue</span> <span class="o">=</span> <span class="n">newman</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">yvalue</span> <span class="o">=</span> <span class="n">newman</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xvalue</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                        <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span> 
                        <span class="n">x</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">xvalue</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">xvalue</span><span class="p">)</span>
                        <span class="n">yvalue</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">yvalue</span><span class="p">)</span>
                    <span class="n">lo_q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">xvalue</span>
                    <span class="n">lo_q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">counter</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yvalue</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">ln</span><span class="p">)</span>   
                <span class="n">det_J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_J</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_r</span><span class="p">):</span>
                    <span class="n">H3</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">H3</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">h3</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">H3</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h3</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">lo_q</span> <span class="o">+=</span> <span class="n">weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">det_J</span><span class="o">*</span><span class="n">H3</span><span class="o">*</span><span class="n">lo_q</span>
                <span class="k">return</span> <span class="n">lo_q</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bc_lines</span><span class="p">[</span><span class="n">ln</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
                    <span class="n">lo_q</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">bc_lines</span><span class="p">[</span><span class="n">ln</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nodes_line</span><span class="p">]:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">newman</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xvalue</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span> 
                            <span class="n">x</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="n">lo_q</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">node_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">ln</span><span class="p">)</span>   
                    <span class="n">det_J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_J</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_r</span><span class="p">):</span>
                        <span class="n">H3</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="n">H3</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">h3</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">lo_q</span> <span class="o">+=</span> <span class="n">weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">det_J</span><span class="o">*</span><span class="n">H3</span><span class="o">*</span><span class="n">lo_q</span>
                <span class="k">return</span> <span class="n">lo_q</span>
                
        </div></div>
<div class="viewcode-block" id="Quadrilaterals"><a class="viewcode-back" href="../Classes.html#Classes.Quadrilaterals">[docs]</a><span class="k">class</span> <span class="nc">Quadrilaterals</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Container for Quadrilateral elements and their methods.</span>
<span class="sd">     </span>
<span class="sd">    QUAD elements are used for meshing 2D plane surfaces, and solving </span>
<span class="sd">    for the unknowns inside a region of the domain.</span>
<span class="sd">    The quad elements supported here are  bi-linear or bi-cuadratic </span>
<span class="sd">    isoparametric elements of 8 nodes. They are best known as serendipity</span>
<span class="sd">    elements.</span>
<span class="sd">    Quadrilateral elements give better accuracy and resistance to </span>
<span class="sd">    locking than triangular elements. </span>
<span class="sd">    </span>
<span class="sd">     </span>
<span class="sd">    :ivar el_set: numpy.array</span>
<span class="sd">        Has the tags and list of nodes for each line element.</span>
<span class="sd">    :ivar n_elements: int</span>
<span class="sd">        number of quads in el_set</span>
<span class="sd">    :ivar order: int</span>
<span class="sd">        Tells of what order the elements are. Order = 0 stands for</span>
<span class="sd">        linear interpolation functions and order = 2 for cuadratic elements.</span>
<span class="sd">        Maximum order is 2.</span>
<span class="sd">    :ivar h: list of lambda functions</span>
<span class="sd">        Is a list where interpolation functions for each node of the element</span>
<span class="sd">        are defined. h depends on the order of the element.</span>

<span class="sd">   &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">raw_quads</span><span class="p">,</span> <span class="n">vectorial</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialization of quadrilateral elements</span>
<span class="sd">        </span>
<span class="sd">        Elements are interpreted according to the number of nodes and</span>
<span class="sd">        interpolation functions get initialized depending on the </span>
<span class="sd">        order of the element.</span>
<span class="sd">        </span>
<span class="sd">        :param raw_quads: numpy.array</span>
<span class="sd">            Has the quads as extracted from function read_mesh_file()</span>
<span class="sd">            of module read_mesh.</span>
<span class="sd">        :keyword vectorial: Boolean</span>
<span class="sd">            Tells if the elements are instantiated as vectorial elements.</span>
<span class="sd">            vectorial = True, builds bigger matrices.        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span> <span class="o">=</span> <span class="n">raw_quads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#Definition of second shape functions according to order and type</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span><span class="p">[</span><span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)]</span> 
        <span class="k">elif</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span><span class="p">[</span><span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">)</span>\
                                                 <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">)</span>\
                                                 <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>\
                                                 <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>\
                                                 <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">),</span>\
                 <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)]</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Not a defined order...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vectorial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span> <span class="o">=</span> <span class="n">vectorial</span>
            
<div class="viewcode-block" id="Quadrilaterals.extract_el_points"><a class="viewcode-back" href="../Classes.html#Classes.Quadrilaterals.extract_el_points">[docs]</a>    <span class="k">def</span> <span class="nf">extract_el_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method for the extracion of coordinates from nodes in a element.</span>
<span class="sd">        </span>
<span class="sd">        Extracts the coordinates of the nodes in each quad element and</span>
<span class="sd">        retrieves an array of node coordinates.</span>
<span class="sd">        </span>
<span class="sd">        loops inside an element reading the indexes of nodes and looks</span>
<span class="sd">        for their coordinates in the matrix of nodes.</span>
<span class="sd">        </span>
<span class="sd">        :param nodes: numpy.array </span>
<span class="sd">            Of dimension (n_nodes, 3), where n_nodes is the </span>
<span class="sd">            number of nodes forming the mesh, and the three columns </span>
<span class="sd">            represent coordinates (x, y, z).</span>
<span class="sd">        :param el_id: int </span>
<span class="sd">            Index of the current element in the set of lines</span>
<span class="sd">        </span>
<span class="sd">        :returns: node_coords: </span>
<span class="sd">                   Array with coordinates of current node. </span>
<span class="sd">                   If the element is 8 node then array is 2*8</span>
<span class="sd">                   If it is a 4 node element then 2*4.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
        <span class="k">if</span> <span class="s">&#39;el_set&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">p2_quads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span>   
                <span class="n">node_coords</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">):</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p2_quads</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p2_quads</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                   
                <span class="k">return</span> <span class="n">node_coords</span>   
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">p1_quads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span>                            
                <span class="n">node_coords</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_quads</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_quads</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">node_coords</span>   
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order elements yet, </span><span class="se">\</span>
<span class="s">                                           there must be an error&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;No elements parsed, do something else&#39;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Quadrilaterals.numeric_J"><a class="viewcode-back" href="../Classes.html#Classes.Quadrilaterals.numeric_J">[docs]</a>    <span class="k">def</span> <span class="nf">numeric_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_coords</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span> <span class="n">dHdrs</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculation of the Jacobian of a QUAD element</span>
<span class="sd">        </span>
<span class="sd">        Determinant of the Jacobian matrix is used for scaling of arbitrary </span>
<span class="sd">        QUAD elements into the isoparametric element defined by </span>
<span class="sd">        interpolation functions h.</span>
<span class="sd">        Also, the inverse of the Jacobian is used in the calculation of </span>
<span class="sd">        the gradient of isoparametric interpolation functions.</span>
<span class="sd">        Right now, only the jacobian of second order QUAD elements is </span>
<span class="sd">        avaialble for solution.</span>
<span class="sd">        The interpolation functions are derivated for coordinates r and s.</span>
<span class="sd">    </span>
<span class="sd">        :param node_coords: numpy.array</span>
<span class="sd">            Array containing coordinates of nodes in the line. As extracted </span>
<span class="sd">            using method Quadrilaterals.extract_el_points().</span>
<span class="sd">        :Parameters: </span>
<span class="sd">            r: x coordinate of an integration point in Gauss-Legendre </span>
<span class="sd">               cuadrature </span>
<span class="sd">            s: x coordinate of an integration point in Gauss-Legendre </span>
<span class="sd">               cuadrature</span>
<span class="sd">        :keyword dHdrs: Boolean</span>
<span class="sd">            If you want the matrix array([dhdr,dhds]) returned, give this as </span>
<span class="sd">            True</span>
<span class="sd">            </span>
<span class="sd">        :returns: J_mat</span>
<span class="sd">            Jacobian matrix             </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">zeros</span>
        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">det</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">J_mat</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dhdr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                    <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                    <span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">+</span> <span class="mi">1</span><span class="p">),</span>\
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>            
            <span class="n">dhds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">4.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> \
                    <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                    <span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                    <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                    <span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;linear quad functions pending&#39;</span><span class="p">)</span>
    
        <span class="n">J_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dhdr</span><span class="p">)</span>
        <span class="n">J_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dhdr</span><span class="p">)</span>
        <span class="n">J_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dhds</span><span class="p">)</span>
        <span class="n">J_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dhds</span><span class="p">)</span>
        <span class="n">det_J</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">J_mat</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">det_J</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;You did something wrong with numbering, because this should be positive&quot;</span>
        <span class="n">inv_J</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">inv_J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">J_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">inv_J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">J_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">inv_J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">J_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">inv_J</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">J_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">inv_J</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">det_J</span> <span class="o">*</span> <span class="n">inv_J</span>
        <span class="k">if</span> <span class="n">dHdrs</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
            <span class="k">return</span> <span class="n">J_mat</span><span class="p">,</span> <span class="n">det_J</span><span class="p">,</span> <span class="n">inv_J</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="n">dhdr</span><span class="p">,</span><span class="n">dhds</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">J_mat</span><span class="p">,</span> <span class="n">det_J</span><span class="p">,</span> <span class="n">inv_J</span>
</div>
<div class="viewcode-block" id="Quadrilaterals.local_potential_matrix"><a class="viewcode-back" href="../Classes.html#Classes.Quadrilaterals.local_potential_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">local_potential_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates the local potential matrix for a QUAD element using Gauss Legendre   quadratures as means for </span>
<span class="sd">        integration.</span>
<span class="sd">        </span>
<span class="sd">        It returns a matrix that gets added to the global mass matrix.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">            nodes:  Array of nodes, attribute node_coord from class Nodes()</span>
<span class="sd">            v:     Potential is a vector that contains values for field </span>
<span class="sd">                   parameters such as gravitational forces in  </span>
<span class="sd">            el_id: Integer that points to a certain element in the el_set</span>
<span class="sd">        :returns: </span>
<span class="sd">            lo_mass: Array defining the local mass matrix of the problem</span>
<span class="sd">                    given by:</span>
<span class="sd">                        int_{\Omega} H^T \bar{\bar{\epsilon}} H det(J) </span>
<span class="sd">                        d \Omega_{el}</span>
<span class="sd">                    Where H = interpolation functions according to whether</span>
<span class="sd">                              the formulation of the problem is scalar or vectorial</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">dot</span>
        <span class="kn">from</span> <span class="nn">scipy.special.orthogonal</span> <span class="kn">import</span> <span class="n">p_roots</span>
        <span class="n">node_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">h8</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span>
            <span class="c"># My own non general purpose integration scheme:</span>
            <span class="c"># Definition of integration degree for each of the coordinates</span>
            <span class="n">deg_r</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">deg_s</span> <span class="o">=</span> <span class="mi">3</span> 
            <span class="c"># Generation of Gauss-Legendre points using scypys&#39;s function:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">weights_r</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_r</span><span class="p">)</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">weights_s</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_s</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                <span class="n">lo_v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span>     
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lo_v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_r</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_s</span><span class="p">):</span>
                    <span class="n">J</span><span class="p">,</span><span class="n">det_J</span><span class="p">,</span><span class="n">invJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_J</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                        <span class="n">H8</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span> 
                        <span class="n">H8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">):</span>
                            <span class="n">H8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">H8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H8</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
                            <span class="n">H8</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>                      
                  
                    <span class="n">lo_v</span> <span class="o">=</span> <span class="n">lo_v</span> <span class="o">+</span> <span class="n">weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">weights_s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span>\
                                        <span class="n">dot</span><span class="p">(</span><span class="n">H8</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">H8</span><span class="p">)</span><span class="o">*</span><span class="n">det_J</span> 
            <span class="n">lo_v</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lo_v</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lo_v</span>  
            </div>
<div class="viewcode-block" id="Quadrilaterals.local_mass_matrix"><a class="viewcode-back" href="../Classes.html#Classes.Quadrilaterals.local_mass_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">local_mass_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        This function calculates the local matrix for a quad element using</span>
<span class="sd">        Gauss Legendre   quadratures as means for integration.</span>
<span class="sd">        It returns a matrix that gets added to the global mass matrix.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            nodes:  Array of nodes, attribute node_coord from class Nodes()</span>
<span class="sd">            el_id: Integer that points to a certain element in the el_set</span>
<span class="sd">        output: </span>
<span class="sd">            lo_mass: Array defining the local mass matrix of the problem</span>
<span class="sd">                    given by:</span>
<span class="sd">                        int_{\Omega} H^T \bar{\bar{\epsilon}} H det(J) d \Omega_{el}</span>
<span class="sd">                    Where H = interpolation functions according to whether</span>
<span class="sd">                              the formulation of the problem is scalar or vectorial</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">dot</span>
        <span class="kn">from</span> <span class="nn">scipy.special.orthogonal</span> <span class="kn">import</span> <span class="n">p_roots</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">node_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>               
            <span class="n">h8</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span>
            <span class="c"># My own non general purpose integration scheme:</span>
            <span class="c"># Definition of integration degree for each of the coordinates</span>
            <span class="n">deg_r</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">deg_s</span> <span class="o">=</span> <span class="mi">3</span> 
            <span class="c"># Generation of Gauss-Legendre points using scypys&#39;s function:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">weights_r</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_r</span><span class="p">)</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">weights_s</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_s</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                <span class="n">lo_mass</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span>     
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lo_mass</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_r</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_s</span><span class="p">):</span>
                    <span class="n">J</span><span class="p">,</span><span class="n">det_J</span><span class="p">,</span><span class="n">invJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_J</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                        <span class="n">H8</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span> 
                        <span class="n">H8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">H8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">):</span>
                            <span class="n">H8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">H8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H8</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
                            <span class="n">H8</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">h8</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>                      
                  
                    <span class="n">lo_mass</span> <span class="o">=</span> <span class="n">lo_mass</span> <span class="o">+</span> <span class="n">weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">weights_s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">epsilon</span><span class="o">*</span>\
                                        <span class="n">dot</span><span class="p">(</span><span class="n">H8</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">H8</span><span class="p">)</span><span class="o">*</span><span class="n">det_J</span> 
            <span class="k">return</span> <span class="n">lo_mass</span></div>
<div class="viewcode-block" id="Quadrilaterals.build_local_stiffness"><a class="viewcode-back" href="../Classes.html#Classes.Quadrilaterals.build_local_stiffness">[docs]</a>    <span class="k">def</span> <span class="nf">build_local_stiffness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         This function calculates the local stiffness matrix for a </span>
<span class="sd">         quad element using Gauss Legendre   quadratures as means for </span>
<span class="sd">         integration.</span>
<span class="sd">         It returns a matrix that gets added to the global stiffness matrix.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            nodes:  Array of nodes, attribute node_coord from class Nodes()</span>
<span class="sd">            el_id: Integer that points to a certain element in the el_set</span>
<span class="sd">        output: </span>
<span class="sd">            lo_stiff: Array defining the local stiffness matrix of the problem</span>
<span class="sd">                    given by:</span>
<span class="sd">                        \[\integrate_\Omega\nabla^2\mathbf{E} \mathbf{E} d\Omega = \integrate_\Gamma \mathbf{W}\cdot (\grad\mathbf{E}\cdot \hat{n})d\Gamma</span>
<span class="sd">                        - \integrate_\Omega \nabla\mathbf{E} : \nabla\mathbf{W} d\Omega  \]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">dot</span>
        <span class="kn">from</span> <span class="nn">scipy.special.orthogonal</span> <span class="kn">import</span> <span class="n">p_roots</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">node_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>               
            <span class="c"># My own non general purpose integration scheme:</span>
            <span class="c"># Definition of integration degree for each of the coordinates</span>
            <span class="n">deg_r</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">deg_s</span> <span class="o">=</span> <span class="mi">3</span> 
            <span class="c"># Generation of Gauss-Legendre points using scypys&#39;s function:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">weights_r</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_r</span><span class="p">)</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">weights_s</span>  <span class="o">=</span> <span class="n">p_roots</span><span class="p">(</span><span class="n">deg_s</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                <span class="n">lo_stiff</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span>     
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lo_stiff</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_r</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_s</span><span class="p">):</span>
                    <span class="n">J</span><span class="p">,</span><span class="n">det_J</span><span class="p">,</span><span class="n">invJ</span><span class="p">,</span> <span class="n">dHdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numeric_J</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dHdrs</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span> 
                    <span class="n">dHdx</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">invJ</span><span class="p">,</span> <span class="n">dHdr</span><span class="p">)</span>                    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                        <span class="n">B8</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span> 
                        <span class="n">B8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">B8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">B8</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">B8</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">):</span>
                            <span class="n">B8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                            <span class="n">B8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                            <span class="n">B8</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                            <span class="n">B8</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">B8</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
                        <span class="n">B8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">B8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">):</span>
                            <span class="n">B8</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                            <span class="n">B8</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">dHdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="n">lo_stiff</span> <span class="o">=</span> <span class="n">lo_stiff</span> <span class="o">+</span> <span class="n">weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">weights_s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span>\
                                        <span class="n">dot</span><span class="p">(</span><span class="n">B8</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">B8</span><span class="p">)</span><span class="o">*</span><span class="n">det_J</span> 
            <span class="k">return</span> <span class="n">lo_stiff</span>                 
            
    </div></div>
<div class="viewcode-block" id="Triangles"><a class="viewcode-back" href="../Classes.html#Classes.Triangles">[docs]</a><span class="k">class</span> <span class="nc">Triangles</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Triangles class is a container for triangular elements and their </span>
<span class="sd">    common methods.</span>
<span class="sd">    </span>
<span class="sd">    Triangular elements are best suited for representing curved boundaries</span>
<span class="sd">    and edges.     </span>
<span class="sd">    </span>
<span class="sd">    Triangles are one kind of very important elements</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_triangles</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span> <span class="o">=</span> <span class="n">raw_triangles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#== Assign a local stiffness for the elements given the order===</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_set</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
            
<div class="viewcode-block" id="Triangles.extract_el_points"><a class="viewcode-back" href="../Classes.html#Classes.Triangles.extract_el_points">[docs]</a>    <span class="k">def</span> <span class="nf">extract_el_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the coordinates of the nodes in each triangular element and</span>
<span class="sd">        retrieves each vertice as a vector of two dimensions.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodes:  numpy array of dimension (n_nodes, 3), where n_nodes is the </span>
<span class="sd">                number of nodes forming the mesh, and the three columns </span>
<span class="sd">                represent coordinates (x, y, z).</span>
<span class="sd">        </span>
<span class="sd">        triangles:  numpy array of dimension (n_triangles, 4), where n_nodes </span>
<span class="sd">                    is the number of nodes forming the mesh, the first is the </span>
<span class="sd">                    label that refers to the physical entity where each node </span>
<span class="sd">                    belongs. The remaining columns  tell which nodes belong</span>
<span class="sd">                    to each of the vertices of the triangle.</span>
<span class="sd">                    </span>
<span class="sd">        el:   integer value of the current element</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        pt_a, pt_b, pt_c:  vector like array of two dimensions where the first </span>
<span class="sd">                           is the position in x, and the second is the position </span>
<span class="sd">                           of the node in y.  </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>
        <span class="k">if</span> <span class="s">&#39;el_set&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">p1_triangles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_set</span>        
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order elements yet,</span><span class="se">\</span>
<span class="s">                                           there must be an error&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;No elements parsed, do something else&#39;</span><span class="p">)</span>
            
        <span class="n">pt_a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">pt_b</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">pt_c</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    
        <span class="n">pt_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_triangles</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pt_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_triangles</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pt_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_triangles</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pt_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_triangles</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pt_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_triangles</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pt_c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">p1_triangles</span><span class="p">[</span><span class="n">el_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pt_a</span><span class="p">,</span> <span class="n">pt_b</span><span class="p">,</span> <span class="n">pt_c</span><span class="p">]</span>
        </div>
<div class="viewcode-block" id="Triangles.extract_el_edges"><a class="viewcode-back" href="../Classes.html#Classes.Triangles.extract_el_edges">[docs]</a>    <span class="k">def</span> <span class="nf">extract_el_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Receive the list of points given by &quot;extract_el_points&quot; and return </span>
<span class="sd">        a list of line segments from which the area can be calculated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt_a</span><span class="p">,</span> <span class="n">pt_b</span><span class="p">,</span> <span class="n">pt_c</span> <span class="o">=</span> <span class="n">points</span> 
        <span class="c">#print pt_a, pt_b, pt_c</span>
        <span class="n">ln_ab</span> <span class="o">=</span> <span class="n">pt_b</span> <span class="o">-</span> <span class="n">pt_a</span>    
        <span class="n">ln_bc</span> <span class="o">=</span> <span class="n">pt_c</span> <span class="o">-</span> <span class="n">pt_b</span>
        <span class="n">ln_ca</span> <span class="o">=</span> <span class="n">pt_a</span> <span class="o">-</span> <span class="n">pt_c</span>    
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">ln_bc</span><span class="p">,</span> <span class="n">ln_ca</span><span class="p">,</span> <span class="n">ln_ab</span><span class="p">]</span>        
        <span class="k">return</span> <span class="n">lines</span>
        </div>
<div class="viewcode-block" id="Triangles.calc_area"><a class="viewcode-back" href="../Classes.html#Classes.Triangles.calc_area">[docs]</a>    <span class="k">def</span> <span class="nf">calc_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the area of a triangle by using Heron&#39;s theorem</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        line:  list of 3 2D arrays. Defines line segments of the triangle</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        area:  float number.          </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
    
        <span class="n">mg_ab</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c"># Calculate the magnitude (mg) of each line</span>
        <span class="n">mg_bc</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">mg_ca</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">mg_ab</span> <span class="o">+</span> <span class="n">mg_bc</span> <span class="o">+</span> <span class="n">mg_ca</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>    <span class="c"># Define the semiperimeter (s)</span>
                                         <span class="c"># for each triangle</span>
       
        <span class="n">area</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mg_ab</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mg_bc</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mg_ca</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">area</span>
    
        </div>
    <span class="k">def</span> <span class="nf">build_local_stiffness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">dot</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_edges</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">calc_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_area</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">calc_area</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="n">lo_stiff</span> <span class="o">=</span>  <span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>  <span class="c"># local (lo) stiffness (stiff) matrix</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">lo_stiff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lines</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">area</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">lo_stiff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order triangles for now&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">local_mass_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">zeros</span>
            <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">det</span>
            <span class="n">tr_mat</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">lo_mass</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">24</span><span class="o">*</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>\
                                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>\
                                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">el_id</span><span class="p">)</span>
            <span class="n">tr_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tr_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">jac</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">tr_mat</span><span class="p">)</span>  
            
            <span class="n">lo_mass</span> <span class="o">=</span> <span class="n">jac</span> <span class="o">*</span> <span class="n">lo_mass</span>    <span class="c"># Escalate acording with the jacobian of the</span>
                                       <span class="c"># transformation </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order triangles for now&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lo_mass</span>
        
    <span class="c">#======================== Local Newman matrix  1D P1 ===========================</span>
    <span class="k">def</span> <span class="nf">local_newman_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
        <span class="n">lo_new</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span> <span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>\
                              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">lo_new</span>
    <span class="c">#======================== Local potential matrix  2D P1 =======================</span>
    <span class="k">def</span> <span class="nf">local_potential_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">el_set</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">el</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">zeros</span>
            <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">det</span>
            <span class="n">vec_v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>   
            <span class="n">vec_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vec_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vec_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tr_mat</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>      <span class="c"># Initiate the transformation (tr) matrix (mat)</span>
            <span class="n">pt_a</span><span class="p">,</span> <span class="n">pt_b</span><span class="p">,</span> <span class="n">pt_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_el_points</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
            <span class="n">tr_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt_b</span> <span class="o">-</span> <span class="n">pt_a</span>
            <span class="n">tr_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt_c</span> <span class="o">-</span> <span class="n">pt_a</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">tr_mat</span><span class="p">)</span>  
            <span class="n">lo_v</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">60</span><span class="o">*</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>\
                                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>\
                                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span> <span class="c"># Local (lo) potential (v) matrix</span>
           
            <span class="n">lo_v</span> <span class="o">=</span> <span class="n">jac</span> <span class="o">*</span> <span class="p">(</span><span class="n">lo_v</span> <span class="o">*</span> <span class="n">vec_v</span><span class="p">)</span>  <span class="c"># Escalate acording with the jacobian </span>
                                       <span class="c"># of the transformation </span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No higher order triangles for now&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lo_v</span></div>
<div class="viewcode-block" id="Boundaries"><a class="viewcode-back" href="../Classes.html#Classes.Boundaries">[docs]</a><span class="k">class</span> <span class="nc">Boundaries</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define what tags from physical entities are associated with certain </span>
<span class="sd">    boundary conditions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirichlet</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">newman</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">bloch</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirichlet</span> <span class="o">=</span> <span class="n">dirichlet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newman</span> <span class="o">=</span> <span class="n">newman</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bloch</span> <span class="o">=</span> <span class="n">bloch</span>           
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_bc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirichlet</span> <span class="o">=</span> <span class="n">_bc</span><span class="p">[</span><span class="s">&#39;Dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newman</span> <span class="o">=</span> <span class="n">_bc</span><span class="p">[</span><span class="s">&#39;New&#39;</span><span class="p">]</span>        
        <span class="k">if</span> <span class="s">&#39;Bloch&#39;</span> <span class="ow">in</span> <span class="n">_bc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bloch</span> <span class="o">=</span> <span class="n">_bc</span><span class="p">[</span><span class="s">&#39;Bloch&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span>
    
<div class="viewcode-block" id="Boundaries.bloch_multiplication"><a class="viewcode-back" href="../Classes.html#Classes.Boundaries.bloch_multiplication">[docs]</a>    <span class="k">def</span> <span class="nf">bloch_multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_x</span><span class="p">,</span> <span class="n">k_y</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">ref_im</span><span class="p">,</span> <span class="o">*</span><span class="n">matrices</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function multiplies a given matrix </span>
<span class="sd">        (in a future a given set of matrices), multiplies each Bloch boundary </span>
<span class="sd">        node, by the phase factor correspondent with it&#39;s position.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        k_x:       Current value of the x component from the wavenumber vector</span>
<span class="sd">         </span>
<span class="sd">        k_y:       Current value of the y component from the wavenumber vector</span>
<span class="sd">        </span>
<span class="sd">        nodes:     Numpy array like matrix of node coordinates (n_nodes,3) where </span>
<span class="sd">               coorsd(x,:)= x,y,z components of the node.</span>
<span class="sd">        </span>
<span class="sd">        ref_im:    A list of 2-column numpy arrays. Each array in the list </span>
<span class="sd">               &#39;ref_im&#39;, has in it&#39;s first column the reference node and on it&#39;s </span>
<span class="sd">               second column the image node for that particular reference node.</span>
<span class="sd">        </span>
<span class="sd">        matrices:  Matrices to be operated.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        matrices:  The input matrix with all the phase multiplication operations </span>
<span class="sd">               performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cmath</span> <span class="kn">import</span> <span class="n">exp</span>
        <span class="k">assert</span> <span class="n">matrices</span> <span class="o">!=</span> <span class="p">[]</span>
        <span class="c"># For each bloch condition in ref_im </span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">ref_im</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ref_im</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])))</span>
        <span class="k">if</span> <span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>    
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">x_im</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y_im</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">fi_x</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_x</span><span class="o">*</span><span class="n">x_im</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_y</span><span class="o">*</span><span class="n">y_im</span><span class="p">)</span>
                <span class="n">fi_y</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_x</span><span class="o">*</span><span class="n">x_im</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_y</span><span class="o">*</span><span class="n">y_im</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
                   <span class="c"># Multiply the column of the image node by the phase factor</span>
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi_x</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> 
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi_y</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> 
                    <span class="c"># Multiply the row of the image node by the comlex conjugate</span>
                    <span class="c">#phase factor            </span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fi_x</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fi_y</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="o">+</span> <span class="mi">1</span><span class="p">,:]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">[::</span><span class="mi">2</span><span class="p">]:</span>      
                <span class="n">x_ref</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y_ref</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ff_x</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_x</span><span class="o">*</span><span class="n">x_ref</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_y</span><span class="o">*</span><span class="n">y_ref</span><span class="p">)</span>
                <span class="n">ff_y</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_x</span><span class="o">*</span><span class="n">x_ref</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_y</span><span class="o">*</span><span class="n">y_ref</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
                   <span class="c"># and the same for the reference node:  </span>
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff_x</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> 
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff_y</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ff_x</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ff_y</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="o">+</span> <span class="mi">1</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">im</span><span class="p">:</span>
                <span class="n">x_im</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y_im</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">fi</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_x</span><span class="o">*</span><span class="n">x_im</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_y</span><span class="o">*</span><span class="n">y_im</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
                   <span class="c"># Multiply the column of the image node by the phase factor</span>
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> 
                    <span class="c"># Multiply the column of the image node by the comlex conjugate</span>
                    <span class="c">#phase factor            </span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">:</span>        
                <span class="n">x_ref</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y_ref</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ff</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_x</span><span class="o">*</span><span class="n">x_ref</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0j</span><span class="o">*</span><span class="n">k_y</span><span class="o">*</span><span class="n">y_ref</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
                   <span class="c"># and the same for the reference node:  </span>
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> 
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        <span class="k">return</span> <span class="n">matrices</span>
    </div>
<div class="viewcode-block" id="Boundaries.bloch_sum"><a class="viewcode-back" href="../Classes.html#Classes.Boundaries.bloch_sum">[docs]</a>    <span class="k">def</span> <span class="nf">bloch_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_im</span><span class="p">,</span> <span class="o">*</span><span class="n">matrices</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function takes the value of the image nodes in bloch periodicity </span>
<span class="sd">        boundaries, and sums it to the value of the reference node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        ref_im:    A list of 2-column numpy arrays. Each array in the list </span>
<span class="sd">                    &#39;ref_im&#39;, has in it&#39;s first column the reference node and on it&#39;s </span>
<span class="sd">                    second column the image node for that particular reference node.</span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        matrices:  Matrices to be operated.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        matrices:  The input matrices but with the sums performed </span>
<span class="sd">                   and the image nodes columns and rows removed. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">delete</span><span class="p">,</span> <span class="n">copy</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_im</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ref_im</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">ref_im</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
                <span class="c"># Sum image node row to reference node row </span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c"># Sum image node column to reference node column</span>
                <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">+</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
                <span class="c">#== stack the values of nodes in vertices for further removal===</span>
                <span class="n">remove</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>       
                <span class="k">if</span> <span class="n">remove</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">remove</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">new_matrices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
            <span class="n">new_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">delete</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">delete</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">remove</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">remove</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">new_matrices</span> </div></div>
<div class="viewcode-block" id="DOF"><a class="viewcode-back" href="../Classes.html#Classes.DOF">[docs]</a><span class="k">class</span> <span class="nc">DOF</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    	A degree of freedom to solve for in a explicit methodology.</span>
<span class="sd">    	Attributes:</span>
<span class="sd">    </span>
<span class="sd">    	node_id: 	Number that represents the row that corresponds to a certain node in </span>
<span class="sd">    				the array of nodes.</span>
<span class="sd">    	boundary:  Boolean. df: false</span>
<span class="sd">    </span>
<span class="sd">    	region:  tells to which region it belongs</span>
<span class="sd">    </span>
<span class="sd">    	vectorial: Tells if the degree of freedom is part of a vectorial formulation.</span>
<span class="sd">    			   for 2D vectorial models we will have two dof&#39;s per node.</span>
<span class="sd">    	comp:  0,1   If vectorial, this will tell if the dof corresponds to x or y component of the field.	</span>
<span class="sd">    </span>
<span class="sd">    	s_elements:  List of surrounding elements </span>
<span class="sd">    </span>
<span class="sd">    	k: 		Componento of the stiffness matrix built using the elements to which it belongs</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">simulation</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vectorial</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">node_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_if_in_boundary</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_if_in_boundary</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Degree of freedom </span><span class="si">%s</span><span class="s"> of node </span><span class="si">%s</span><span class="s"> is shared by elements:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span>\
    		<span class="s">&quot;and its Fi is </span><span class="si">%s</span><span class="s"> </span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">s_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_i</span><span class="p">)</span>		
<div class="viewcode-block" id="DOF.find_surrounding_elements"><a class="viewcode-back" href="../Classes.html#Classes.DOF.find_surrounding_elements">[docs]</a>    <span class="k">def</span> <span class="nf">find_surrounding_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">simulation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over elements looking for reference to the current node_id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes_coords</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">coords</span>            
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">regions</span><span class="p">:</span>
            <span class="n">all_elements</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">elements</span>
            <span class="k">for</span> <span class="n">el_class</span> <span class="ow">in</span> <span class="n">all_elements</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">all_elements</span><span class="p">[</span><span class="n">el_class</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">elements</span><span class="o">.</span><span class="n">vectorial</span><span class="p">:</span>
                    <span class="n">n_elements</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">n_elements</span>   
                    <span class="n">el_set</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">el_set</span>
                    <span class="k">if</span> <span class="n">el_set</span> <span class="o">==</span> <span class="p">[]:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_elements</span><span class="p">):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">s_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="n">el_class</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
                                <span class="n">lo_stif</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">build_local_stiffness</span><span class="p">(</span><span class="n">nodes_coords</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">simulation</span><span class="o">.</span><span class="n">sim_type</span> <span class="o">==</span> <span class="s">&#39;EM&#39;</span><span class="p">:</span>
                                    <span class="n">mu</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">material_prop</span><span class="p">[</span><span class="s">&#39;mu&#39;</span><span class="p">]</span>
                                    <span class="n">lo_stif</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">mu</span> <span class="o">*</span> <span class="n">lo_stif</span>
                                <span class="k">elif</span> <span class="n">simulation</span><span class="o">.</span><span class="n">sim_type</span> <span class="o">==</span> <span class="s">&#39;QM&#39;</span><span class="p">:</span>
                                    <span class="n">h</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">material_prop</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
                                    <span class="n">m</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">material_prop</span><span class="p">[</span><span class="s">&#39;m&#39;</span><span class="p">]</span>
                                    <span class="n">lo_stif</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">lo_stif</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> Not a simulation type&#39;</span><span class="o">%</span><span class="n">simulation</span><span class="o">.</span><span class="n">sim_type</span><span class="p">)</span> 
                                <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">append</span>
                                <span class="n">u</span> <span class="o">=</span> <span class="n">array</span><span class="p">([])</span>
                                
                                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                                    <span class="n">u</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dofs</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                                    <span class="n">u</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dofs</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                                       
<span class="c">#                                if self.node_id == 107:</span>
<span class="c">#                                    print &#39;el_set[el][1:]&#39;,el_set[el][1:]</span>
<span class="c">#                                    print u,</span>
<span class="c">#                                    for dof in dofs:</span>
<span class="c">#                                        print &#39;dof.node_id&#39;,dof.node_id, &#39;value&#39;, dof.value    </span>
                                <span class="n">pivot</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">k_row</span> <span class="o">=</span> <span class="n">lo_stif</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">pivot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,:]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">F_i</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">k_row</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
                                
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_elements</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">n_elements</span>
                    <span class="n">el_set</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">el_set</span>
                    <span class="k">if</span> <span class="n">el_set</span> <span class="o">==</span> <span class="p">[]:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_elements</span><span class="p">):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span>  <span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">s_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="n">el_class</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
                                <span class="n">lo_stif</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">build_local_stiffness</span><span class="p">(</span><span class="n">nodes_coords</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">simulation</span><span class="o">.</span><span class="n">sim_type</span> <span class="o">==</span> <span class="s">&#39;EM&#39;</span><span class="p">:</span>
                                    <span class="n">mu</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">material_prop</span><span class="p">[</span><span class="s">&#39;mu&#39;</span><span class="p">]</span>
                                    <span class="n">lo_stif</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">mu</span> <span class="o">*</span> <span class="n">lo_stif</span>
                                <span class="k">elif</span> <span class="n">simulation</span><span class="o">.</span><span class="n">sim_type</span> <span class="o">==</span> <span class="s">&#39;QM&#39;</span><span class="p">:</span>
                                    <span class="n">h</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">material_prop</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">]</span>
                                    <span class="n">m</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">material_prop</span><span class="p">[</span><span class="s">&#39;m&#39;</span><span class="p">]</span>
                                    <span class="n">lo_stif</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">lo_stif</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> Not a simulation type&#39;</span><span class="o">%</span><span class="n">simulation</span><span class="o">.</span><span class="n">sim_type</span><span class="p">)</span> 
                                <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">where</span>       
                                <span class="n">pivot</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">el_set</span><span class="p">[</span><span class="n">el</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">pivot</span> <span class="o">-=</span> <span class="mi">1</span>
                                <span class="n">k_row</span> <span class="o">=</span> <span class="n">lo_stif</span><span class="p">[</span><span class="n">pivot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,:][</span><span class="mi">0</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">F_i</span> <span class="o">+=</span> <span class="n">dot</span><span class="p">(</span><span class="n">k_row</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_i</span></div>
<div class="viewcode-block" id="DOF.check_if_in_boundary"><a class="viewcode-back" href="../Classes.html#Classes.DOF.check_if_in_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">check_if_in_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run throug line elements checking if this degree of freedom </span>
<span class="sd">        belongs to a bc line defined by a bc condition.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        simulation:     Instance of class Simulation()</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        ln:     the number of the line to which the dof belongs </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bc_lines</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">el_set</span>
        <span class="n">n_lines</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">n_elements</span>
        <span class="n">vectorial</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">vectorial</span>
        <span class="n">dirichlet</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">boundaries</span><span class="o">.</span><span class="n">dirichlet</span>
        <span class="k">if</span> <span class="n">vectorial</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">dirichlet</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lines</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bc_lines</span><span class="p">[</span><span class="n">ln</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">bc_lines</span><span class="p">[</span><span class="n">ln</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>  
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                        
                                <span class="n">value</span> <span class="o">=</span> <span class="n">dirichlet</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">dirichlet</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                                <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span> 
                                <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">isnan</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                                <span class="n">y</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                                <span class="kn">import</span> <span class="nn">re</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
                                <span class="k">exec</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                <span class="k">print</span> <span class="n">value</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;value should be already&quot;</span> \
                                                    <span class="s">&quot;evaluated something happened&quot;</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">):</span> 
                                        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
                                        <span class="k">print</span> <span class="s">&#39;value has been reassigned due to </span><span class="se">\</span>
<span class="s">                                          division by zero&#39;</span>
                                
                                    <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span> 
                                    
                            <span class="k">else</span><span class="p">:</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                                
                                
                            <span class="k">return</span> <span class="s">&quot;This DOF belongs to line </span><span class="si">%s</span><span class="s"> of bc with &quot;</span>\
                            <span class="s">&quot;tag </span><span class="si">%s</span><span class="s">.</span><span class="se">\n</span><span class="s"> Value </span><span class="si">%s</span><span class="s"> has been assigned to the DOF&quot;</span>\
                            <span class="o">%</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">dirichlet</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
        	<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Wait please&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>         </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">peyeQM 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Santiago Echeverri, Nicol√°s Guar√≠n, Edward Villegas.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>