%
% API Documentation for API Documentation
% Module Classes
%
% Generated by epydoc 3.0.1
% [Sun May  5 12:10:50 2013]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}|(}
\section{Module Classes}

    \label{Classes}
Classes module specifications.

Module Classes holds many of the classes used by PeYeQM to define the 
instances necessary for the initial statement of a simulation problem.

(section) List of Classes

  (section) Simulation()

    Top level class of a FEA. It contains as attributes all other classes 
    listed below. It has

    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Definition of the problem.

      \item Details about the context of the solution.

    \end{itemize}

  (section) Domain()

    Representation of the physical domain of a simulation. It has:

    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Information about regions and their discretization

      \item definitions of elements, nodes and boundary conditions

    \end{itemize}

  (section) Region()

    A region is an object that allows the identification of different 
    material properties according to a previous subdivision of the Domain.

  (section) Nodes()

    Class Nodes represents the coordinates of the points that result from a
    discretization of a given domain.

  (section) Elements()

    Class elements is a container for sets of 1D and 2D elements that can 
    be of different shapes and orders. Elements are representations of the 
    relation between nodes of a discretized domain. Current supported 
    elements are:

    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item Lines

      \item Triangles

      \item Quadrilaterals

    \end{itemize}

  (section) Lines()

    An instance of class Lines() is a container of line elements. This 
    class also defines common operations and attributes that involve line 
    elements.

  (section) Triangles()

    An instance of class Triangles() is a container of triangular elements.
    This class also defines common operations and attributes that involve 
    triangular elements.

  (section) Quadrilaterals()

    An instance of class Quadrilaterals() is a container of QUAD elements. 
    This class also defines common operations and attributes that involve 
    QUAD elements.

  (section) Boundaries()

    This class acts as a container of boundaries and their attributes. 
    Boundaries of a domain are the objects where edge conditions are 
    stated. DOF() -----

\textbf{Author:} Santiago Echeverri Chac{\textbackslash}xc3{\textbackslash}xb3n




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt None}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}|(}
\subsection{Class Boundaries}

    \label{Classes:Boundaries}
Define what tags from physical entities are associated with certain 
boundary conditions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Boundaries:__init__}
    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}!Classes.Boundaries.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{dirichlet}={\tt \texttt{\{}\texttt{\}}}, \textit{newman}={\tt \texttt{\{}\texttt{\}}}, \textit{bloch}={\tt \texttt{\{}\texttt{\}}})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Boundaries:__str__}
    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}!Classes.Boundaries.\_\_str\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Boundaries:add}
    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}!Classes.Boundaries.add \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{add}(\textit{self}, \textit{\_bc})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Boundaries:bloch_multiplication}
    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}!Classes.Boundaries.bloch\_multiplication \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{bloch\_multiplication}(\textit{self}, \textit{k\_x}, \textit{k\_y}, \textit{nodes}, \textit{ref\_im}, *\textit{matrices})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

This function multiplies a given matrix 
(in a future a given set of matrices), multiplies each Bloch boundary 
node, by the phase factor correspondent with it's position.

Parameters:
-----------
k\_x:       Current value of the x component from the wavenumber vector
 
k\_y:       Current value of the y component from the wavenumber vector

nodes:     Numpy array like matrix of node coordinates (n\_nodes,3) where 
       coorsd(x,:)= x,y,z components of the node.

ref\_im:    A list of 2-column numpy arrays. Each array in the list 
       'ref\_im', has in it's first column the reference node and on it's 
       second column the image node for that particular reference node.

matrices:  Matrices to be operated.

Returns:
--------

matrices:  The input matrix with all the phase multiplication operations 
       performed.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Boundaries:bloch_sum}
    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}!Classes.Boundaries.bloch\_sum \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{bloch\_sum}(\textit{self}, \textit{ref\_im}, *\textit{matrices})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

This function takes the value of the image nodes in bloch periodicity 
boundaries, and sums it to the value of the reference node.

Parameters:
-----------

ref\_im:    A list of 2-column numpy arrays. Each array in the list 
            'ref\_im', has in it's first column the reference node and on it's 
            second column the image node for that particular reference node.

    
matrices:  Matrices to be operated.

Returns:
-------

matrices:  The input matrices but with the sums performed 
           and the image nodes columns and rows removed. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Boundaries \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.DOF \textit{(class)}|(}
\subsection{Class DOF}

    \label{Classes:DOF}
\begin{alltt}

A degree of freedom to solve for in a explicit methodology.
Attributes:

node\_id:        Number that represents the row that corresponds to a certain node in 
                        the array of nodes.
boundary:  Boolean. df: false

region:  tells to which region it belongs

vectorial: Tells if the degree of freedom is part of a vectorial formulation.
                   for 2D vectorial models we will have two dof's per node.
comp:  0,1   If vectorial, this will tell if the dof corresponds to x or y component of the field.      

s\_elements:  List of surrounding elements 

k:              Componento of the stiffness matrix built using the elements to which it belongs
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:DOF:__init__}
    \index{Classes \textit{(module)}!Classes.DOF \textit{(class)}!Classes.DOF.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{node\_id}, \textit{simulation}, \textit{t}={\tt None}, \textit{comp}={\tt 0}, \textit{vectorial}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DOF:__str__}
    \index{Classes \textit{(module)}!Classes.DOF \textit{(class)}!Classes.DOF.\_\_str\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DOF:check_if_in_boundary}
    \index{Classes \textit{(module)}!Classes.DOF \textit{(class)}!Classes.DOF.check\_if\_in\_boundary \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{check\_if\_in\_boundary}(\textit{self}, \textit{simulation}, \textit{t}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Run throug line elements checking if this degree of freedom 
belongs to a bc line defined by a bc condition.

Parameters:
-----------
simulation:     Instance of class Simulation()

Returns:
-------

ln:     the number of the line to which the dof belongs 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DOF:find_surrounding_elements}
    \index{Classes \textit{(module)}!Classes.DOF \textit{(class)}!Classes.DOF.find\_surrounding\_elements \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{find\_surrounding\_elements}(\textit{self}, \textit{dofs}, \textit{simulation})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Loop over elements looking for reference to the current node\_id

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright v\-a\-l\-u\-e\- & \raggedright \textbf{Value:} 
{\tt 0.0}&\\
\cline{1-2}
\end{longtable}

    \index{Classes \textit{(module)}!Classes.DOF \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Domain \textit{(class)}|(}
\subsection{Class Domain}

    \label{Classes:Domain}
\begin{alltt}

Instances from Domain Class contain the attributes that define 
characteristics of the simulation such as regions, meshing, and 
boundary conditions.
To be included here are instances of other clases such as:
    * Nodes.
    * Elements 
    * And boundaries.
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Domain:__init_}
    \index{Classes \textit{(module)}!Classes.Domain \textit{(class)}!Classes.Domain.\_\_init\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Domain:read_bc_file}
    \index{Classes \textit{(module)}!Classes.Domain \textit{(class)}!Classes.Domain.read\_bc\_file \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{read\_bc\_file}(\textit{self}, \textit{filename})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Domain:read_mesh_file}
    \index{Classes \textit{(module)}!Classes.Domain \textit{(class)}!Classes.Domain.read\_mesh\_file \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{read\_mesh\_file}(\textit{self}, \textit{filename}, \textit{vectorial}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Domain:read_regions_file}
    \index{Classes \textit{(module)}!Classes.Domain \textit{(class)}!Classes.Domain.read\_regions\_file \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{read\_regions\_file}(\textit{self}, \textit{filename})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Domain \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Elements \textit{(class)}|(}
\subsection{Class Elements}

    \label{Classes:Elements}
Elements for now counts the number f line and triangle elements in a format
imported from a file by using function read\_mesh().

The Idea is that the instance elements contains all the attributes 
associated with elements


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Elements:__init__}
    \index{Classes \textit{(module)}!Classes.Elements \textit{(class)}!Classes.Elements.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Elements:add}
    \index{Classes \textit{(module)}!Classes.Elements \textit{(class)}!Classes.Elements.add \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{add}(\textit{self}, \textit{\_elements}, \textit{vectorial}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Elements \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Lines \textit{(class)}|(}
\subsection{Class Lines}

    \label{Classes:Lines}
Line elements are used for solving 1D problems and handling boundary 
conditions. The instance lines has been made in order to contain properties
that are defined exlusively for line elements such as stiffness matrices 
for 1D problems and interpolation methods for newman and source vectors.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Lines:__init__}
    \index{Classes \textit{(module)}!Classes.Lines \textit{(class)}!Classes.Lines.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{raw\_lines}, \textit{vectorial}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Lines:extract_el_points}
    \index{Classes \textit{(module)}!Classes.Lines \textit{(class)}!Classes.Lines.extract\_el\_points \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extract\_el\_points}(\textit{self}, \textit{\_nodes}, \textit{el\_id})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Extracts the coordinates of the nodes in each line element and
retrieves an array of node coordinates.

Parameters:
-----------
nodes:  numpy array of dimension (n\_nodes, 3), where n\_nodes is the 
        number of nodes forming the mesh, and the three columns 
        represent coordinates (x, y, z).
            
el\_id:   integer value of the current element

Returns:
--------
node\_coor: Array with coordinates of coordinate node. 
           If the element is 3 node then array is 2*3
           If it is a 2 node element then 2*2.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Lines:local_newman}
    \index{Classes \textit{(module)}!Classes.Lines \textit{(class)}!Classes.Lines.local\_newman \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{local\_newman}(\textit{self}, \textit{q}, \textit{nodes}, \textit{newman}, \textit{tag}, \textit{ln}, \textit{vectorial}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the nodal values for a certain newman boundary line element by 
    using the specific definition from the.bc file.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Lines:numeric_J}
    \index{Classes \textit{(module)}!Classes.Lines \textit{(class)}!Classes.Lines.numeric\_J \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{numeric\_J}(\textit{self}, \textit{node\_coords})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Lines \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Nodes \textit{(class)}|(}
\subsection{Class Nodes}

    \label{Classes:Nodes}
Nodes, will be a instance fo handling nodes. Right now its only two 
attributes are the total number of nodes and the array of ccordinates.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Nodes:add}
    \index{Classes \textit{(module)}!Classes.Nodes \textit{(class)}!Classes.Nodes.add \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{add}(\textit{self}, \textit{\_nodes})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Nodes \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}|(}
\subsection{Class Quadrilaterals}

    \label{Classes:Quadrilaterals}
Quadrilateral elements give better accuracy and resistance to locking than 
triangular elements. They can also be more economic when meshing compared 
to their equivalent triangular peers. Option vectorial will initiate base 
functions and nodal representation that accounts for components of the 
solution function. This means that there will be x and y components of the 
solution.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Quadrilaterals:__init__}
    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}!Classes.Quadrilaterals.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{raw\_quads}, \textit{vectorial}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Quadrilaterals:build_local_stiffness}
    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}!Classes.Quadrilaterals.build\_local\_stiffness \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{build\_local\_stiffness}(\textit{self}, \textit{nodes}, \textit{el\_id})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

         This function calculates the local stiffness matrix for a 
         quad element using Gauss Legendre   quadratures as means for 
         integration.
         It returns a matrix that gets added to the global stiffness matrix.
        
        Parameters:
            nodes:  Array of nodes, attribute node\_coord from class Nodes()
            el\_id: Integer that points to a certain element in the el\_set
        output: 
            lo\_stiff: Array defining the local stiffness matrix of the problem
                    given by:
                        {\textbackslash}[{\textbackslash}integrate\_{\textbackslash}Omega
abla{\textasciicircum}2{\textbackslash}mathbf\{E\} {\textbackslash}mathbf\{E\} d{\textbackslash}Omega = {\textbackslash}integrate\_{\textbackslash}Gamma {\textbackslash}mathbf\{W\}{\textbackslash}cdot ({\textbackslash}grad{\textbackslash}mathbf\{E\}{\textbackslash}cdot {\textbackslash}hat\{n\})d{\textbackslash}Gamma
                        - {\textbackslash}integrate\_{\textbackslash}Omega 
abla{\textbackslash}mathbf\{E\} : 
abla{\textbackslash}mathbf\{W\} d{\textbackslash}Omega  {\textbackslash}]
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Quadrilaterals:extract_el_points}
    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}!Classes.Quadrilaterals.extract\_el\_points \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extract\_el\_points}(\textit{self}, \textit{\_nodes}, \textit{el\_id})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Extracts the coordinates of the nodes in each quad element and
retrieves an array of node coordinates.

Parameters:
-----------
nodes:  numpy array of dimension (n\_nodes, 3), where n\_nodes is the 
        number of nodes forming the mesh, and the three columns 
        represent coordinates (x, y, z).
            
el\_id:   integer value of the current element

Returns:
--------
node\_coor: Array with coordinates of coordinate node. 
           If the element is 8 node then array is 2*8
           If it is a 4 node element then 2*4.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Quadrilaterals:local_mass_matrix}
    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}!Classes.Quadrilaterals.local\_mass\_matrix \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{local\_mass\_matrix}(\textit{self}, \textit{nodes}, \textit{el\_id})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

This function calculates the local matrix for a quad element using
Gauss Legendre   quadratures as means for integration.
It returns a matrix that gets added to the global mass matrix.

Parameters:
    nodes:  Array of nodes, attribute node\_coord from class Nodes()
    el\_id: Integer that points to a certain element in the el\_set
output: 
    lo\_mass: Array defining the local mass matrix of the problem
            given by:
                int\_\{{\textbackslash}Omega\} H{\textasciicircum}T ar\{ar\{{\textbackslash}epsilon\}\} H det(J) d {\textbackslash}Omega\_\{el\}
            Where H = interpolation functions according to whether
                      the formulation of the problem is scalar or vectorial
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Quadrilaterals:local_potential_matrix}
    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}!Classes.Quadrilaterals.local\_potential\_matrix \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{local\_potential\_matrix}(\textit{self}, \textit{nodes}, \textit{v}, \textit{el\_id})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

This function calculates the local potential matrix for a quad
element using Gauss Legendre   quadratures as means for 
integration.
It returns a matrix that gets added to the global mass matrix.

Parameters:
    nodes:  Array of nodes, attribute node\_coord from class Nodes()
    v:     Potential is a vector that contains values for field 
           parameters such as gravitational forces in  
    el\_id: Integer that points to a certain element in the el\_set
output: 
    lo\_mass: Array defining the local mass matrix of the problem
            given by:
                int\_\{{\textbackslash}Omega\} H{\textasciicircum}T ar\{ar\{{\textbackslash}epsilon\}\} H det(J) 
                d {\textbackslash}Omega\_\{el\}
            Where H = interpolation functions according to whether
                      the formulation of the problem is scalar or vectorial
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Quadrilaterals:numeric_J}
    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}!Classes.Quadrilaterals.numeric\_J \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{numeric\_J}(\textit{self}, \textit{node\_coords}, \textit{r}, \textit{s}, \textit{dHdrs}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}
I should document more often, now I don't get how this            function work.
Parameters:
    node\_coords:    Array that contains coordinates of nodes
    r, s:   
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Quadrilaterals \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Region \textit{(class)}|(}
\subsection{Class Region}

    \label{Classes:Region}
Reperesents a region of the Domain. It is thought as a way to store 
attributes that are specific to certain regions such as the kind of 
elements that compose it, it's distinctive tag, and material properties


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Region:__init__}
    \index{Classes \textit{(module)}!Classes.Region \textit{(class)}!Classes.Region.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{tag}={\tt \texttt{'}\texttt{}\texttt{'}}, \textit{name}={\tt \texttt{'}\texttt{}\texttt{'}}, \textit{material\_prop}={\tt \texttt{\{}\texttt{\}}}, \textit{elements}={\tt \texttt{\{}\texttt{\}}})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Region:__str__}
    \index{Classes \textit{(module)}!Classes.Region \textit{(class)}!Classes.Region.\_\_str\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Region \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Simulation \textit{(class)}|(}
\subsection{Class Simulation}

    \label{Classes:Simulation}
\begin{alltt}

Instances from this class act as a container for the overal 
problem definition of the simulation.
A simulation instance is meant to contain information about:
    * The Domain and its discretization.
    * Options and configuration.
    *Type of simulations and solvers to be used.
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Simulation:__init__}
    \index{Classes \textit{(module)}!Classes.Simulation \textit{(class)}!Classes.Simulation.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Simulation:__str__}
    \index{Classes \textit{(module)}!Classes.Simulation \textit{(class)}!Classes.Simulation.\_\_str\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Simulation:read_solver_input}
    \index{Classes \textit{(module)}!Classes.Simulation \textit{(class)}!Classes.Simulation.read\_solver\_input \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{read\_solver\_input}(\textit{self}, \textit{filename})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Reads the solver input from a file of gmsh ASCII format V2.2.
This input is to be read by the Solver module.
Parameters:
-----------
filename: String which contain filename and path of the output file.
Returns:
--------
solver\_input: List with the following parameters:

[dimension,bc\_type,parameter,eq,sol\_type,analysis\_param]

dimension:  int parameter that tells the program wether to solve for a
        1D problem or a 2D problem (not supported yet)

bc\_type:     String parameter for the selection of a border condition
            that can be either:

                'Dir'   For the Dirichlet border condition
                        (Infinite potential well).

                'Bloch' For the periodic formulation of the problem.
                        (Electron in a periodic material )
        
body\_parameter:  
        Is an array that describes the potential actuating over the
        the elements of the domain given by Elems. For each element in
        Elems there is an associated potential value on the same
        position in the array parameter.

        The potential in Scroedinger equation defines the specific
        nature of the problem to be solved. For more details on how
        to define a potential and what does it mean pleas read the
        documentation of the Potential1D function in the module PrePro.


sim\_type: Can be 'QM' from Quantum Mechanics, or 'EM' for 
          electromagnetism.


sol\_type:       String that tells wether to solve the stationary version of
            the equation or another not yet suported.

            'Stationary'   

solver\_param:   Array that contains the information regarding the number
                 of solutions to be computed and wether to save the values
                 or not.

                analysis\_param[0]:  String  answer to the question
                                           save  Eigen Values?
                analysis\_param[1]:  String  answer to the question
                                           save  Eigen Vectors?
                analysis\_param[2]:  Integer  number of Eigen Values to save
                analysis\_param[3]:  Integer  number of Eigen Vectors to save 
                analysis\_param[4]:  Integer number of wave numbers 
                                    in x to sweep
                analysis\_param[5]:  Integer number of wave numbers 
                                    in y to sweep
                analysis\_param[6]:  biggest value of k. it may be the lenght
                                    of the dommain                                        
                
bc\_filename:    string that tells where to look for the boundary 
                conditions  
                    
 Last modification: date 12/02/2013
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright d\-i\-m\-e\-n\-s\-i\-o\-n\- & \raggedright \textbf{Value:} 
{\tt 2}&\\
\cline{1-2}
\raggedright s\-i\-m\-\_\-t\-y\-p\-e\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{QM}\texttt{'}}&\\
\cline{1-2}
\raggedright t\-i\-m\-e\-\_\-d\-e\-p\-e\-n\-d\-e\-n\-c\-y\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Stationary}\texttt{'}}&\\
\cline{1-2}
\end{longtable}

    \index{Classes \textit{(module)}!Classes.Simulation \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}|(}
\subsection{Class Triangles}

    \label{Classes:Triangles}
Triangles are one kind of very important elements


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:Triangles:__init__}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{raw\_triangles})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:build_local_stiffness}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.build\_local\_stiffness \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{build\_local\_stiffness}(\textit{self}, \textit{nodes}, \textit{el\_id})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:calc_area}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.calc\_area \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{calc\_area}(\textit{self}, \textit{lines})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Calculates the area of a triangle by using Heron's theorem

Parameters:
-----------
line:  list of 3 2D arrays. Defines line segments of the triangle

Returns:
--------
area:  float number.          
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:extract_el_edges}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.extract\_el\_edges \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extract\_el\_edges}(\textit{self}, \textit{points})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Receive the list of points given by "extract\_el\_points" and return a 
    list of line segments from which the area can be calculated

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:extract_el_points}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.extract\_el\_points \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extract\_el\_points}(\textit{self}, \textit{\_nodes}, \textit{el\_id})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Extracts the coordinates of the nodes in each triangular element and
retrieves each vertice as a vector of two dimensions.

Parameters:
-----------
nodes:  numpy array of dimension (n\_nodes, 3), where n\_nodes is the 
        number of nodes forming the mesh, and the three columns 
        represent coordinates (x, y, z).

triangles:  numpy array of dimension (n\_triangles, 4), where n\_nodes 
            is the number of nodes forming the mesh, the first is the 
            label that refers to the physical entity where each node 
            belongs. The remaining columns  tell which nodes belong
            to each of the vertices of the triangle.
            
el:   integer value of the current element

Returns:
--------
pt\_a, pt\_b, pt\_c:  vector like array of two dimensions where the first 
                   is the position in x, and the second is the position 
                   of the node in y.  
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:local_mass_matrix}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.local\_mass\_matrix \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{local\_mass\_matrix}(\textit{self}, \textit{nodes}, \textit{el\_id})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:local_newman_matrix}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.local\_newman\_matrix \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{local\_newman\_matrix}()

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:Triangles:local_potential_matrix}
    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}!Classes.Triangles.local\_potential\_matrix \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{local\_potential\_matrix}(\textit{self}, \textit{nodes}, \textit{el\_set}, \textit{v}, \textit{el})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(module)}!Classes.Triangles \textit{(class)}|)}
    \index{Classes \textit{(module)}|)}
